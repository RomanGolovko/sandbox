<?xml version="1.0"?>
<doc>
  <assembly>
    <name>FlitBit.Core</name>
  </assembly>
  <members>
    <member name="T:FlitBit.Core.Log.DefaultLogSequenceGenerator">
      <summary>
            Default log sequence generator.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.ILogSequenceGenerator">
      <summary>
            Generates sequential identities for trace events originating from the process.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSequenceGenerator.Next">
      <summary>
            Generates the next identifier in the sequence.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.DefaultLogSequenceGenerator.Next">
      <summary>
            Generates the next sequence number.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.LogEventWriter">
      <summary>
              Writes log events onto a more durable store or to another resource.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogEventWriter.NullWriter">
      <summary>
              An event writer stub for use when no configuration exists.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogEventWriter.Initialize(System.String)">
      <summary>
              Initializes the event writer.
            </summary>
      <param name="sourceName">the name of the log source that will be using the writer.</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogEventWriter.WriteLogEvent(FlitBit.Core.Log.LogEvent)">
      <summary>
              Writes log events.
            </summary>
      <param name="evt">the event</param>
    </member>
    <member name="T:FlitBit.Core.Log.LogSequenceGenerator">
      <summary>
            Utility class for accessing log sequence numbers.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogSequenceGenerator.SetGeneratorType(System.Type)">
      <summary>
            Sets the generator type. Must be called before any log events are generated.
            </summary>
      <param name="type" />
      <requires exception="T:System.ArgumentException" csharp="typeof(FlitBit.Core.Log.ILogSequenceGenerator).IsAssignableFrom(type)" vb="typeof(FlitBit.Core.Log.ILogSequenceGenerator).IsAssignableFrom(type)">typeof(FlitBit.Core.Log.ILogSequenceGenerator).IsAssignableFrom(type)</requires>
      <exception cref="T:System.ArgumentException">!typeof(FlitBit.Core.Log.ILogSequenceGenerator).IsAssignableFrom(type)</exception>
      <requires exception="T:System.InvalidOperationException" csharp="!HasSequenceGenerator" vb="Not HasSequenceGenerator">!FlitBit.Core.Log.LogSequenceGenerator.HasSequenceGenerator</requires>
      <exception cref="T:System.InvalidOperationException">FlitBit.Core.Log.LogSequenceGenerator.HasSequenceGenerator</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSequenceGenerator.SetGenerator(FlitBit.Core.Log.ILogSequenceGenerator)">
      <summary>
            Sets the generator. Must be called before any log events are generated.
            </summary>
      <param name="generator" />
      <requires exception="T:System.ArgumentNullException" csharp="generator != null" vb="generator &lt;&gt; Nothing">generator != null</requires>
      <exception cref="T:System.ArgumentNullException">generator == null</exception>
      <requires exception="T:System.InvalidOperationException" csharp="!HasSequenceGenerator" vb="Not HasSequenceGenerator">!FlitBit.Core.Log.LogSequenceGenerator.HasSequenceGenerator</requires>
      <exception cref="T:System.InvalidOperationException">FlitBit.Core.Log.LogSequenceGenerator.HasSequenceGenerator</exception>
    </member>
    <member name="P:FlitBit.Core.Log.LogSequenceGenerator.Next">
      <summary>
            Gets the next sequence number.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSequenceGenerator.HasSequenceGenerator">
      <summary>
            Indicates whether the generator has already been used.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.ContextFlow">
      <summary>
              Utility class for managing context flow.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Disposable">
      <summary>
              Abstract logic for disposable objects.
            </summary>
    </member>
    <member name="T:FlitBit.Core.IInterrogateDisposable">
      <summary>
              Interface for disposable objects that can be interrogated about their disposed state.
            </summary>
    </member>
    <member name="P:FlitBit.Core.IInterrogateDisposable.IsDisposed">
      <summary>
              Indicates whether the disposable has been disposed.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.#ctor(System.Boolean)">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.Finalize">
      <summary>
              Finalizes the instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.Dispose">
      <summary>
              Disposes the instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Disposable.PerformDispose(System.Boolean)">
      <summary>
              Performs the dispose logic.
            </summary>
      <param name="disposing">Whether the object is disposing (IDisposable.Dispose method was called).</param>
      <returns>Implementers should return true if the disposal was successful; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.Core.Disposable.CreationStack">
      <summary>
              Exposes the call stack at the time of creation if the subtype indicated that it should be captured.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Disposable.IsDisposed">
      <summary>
              Indicates whether the instance has been disposed.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.NotifyUncaughtException(System.Object,System.Exception)">
      <summary>
              Notifies event handlers that an exception has occurred in a paralle operation.
            </summary>
      <param name="sender">the sender</param>
      <param name="e">the exception that was raised.</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture(System.Action)">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``1(System.Action{``0})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``2(System.Action{``0,``1})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``3(System.Action{``0,``1,``2})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``4(System.Action{``0,``1,``2,``3})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``5(System.Action{``0,``1,``2,``3,``4})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``6(System.Action{``0,``1,``2,``3,``4,``5})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``7(System.Action{``0,``1,``2,``3,``4,``5,``6})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``8(System.Action{``0,``1,``2,``3,``4,``5,``6,``7})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``9(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``10(System.Action{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``1(System.Func{``0})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``2(System.Func{``0,``1})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``3(System.Func{``0,``1,``2})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``4(System.Func{``0,``1,``2,``3})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``5(System.Func{``0,``1,``2,``3,``4})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``6(System.Func{``0,``1,``2,``3,``4,``5})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``7(System.Func{``0,``1,``2,``3,``4,``5,``6})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``9(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``10(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.Capture``11(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,``8,``9,``10})">
      <summary>
              Creates an action that restores the ambient context around the specified task.
            </summary>
      <param name="task" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.#ctor(System.Collections.Generic.List{System.Tuple{FlitBit.Core.Parallel.IContextFlowProvider,System.Object}})">
      <summary />
      <param name="contexts" />
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.PerformDispose(System.Boolean)">
      <summary>
              Performs the disposal.
            </summary>
      <param name="disposing">indicates whether the context is disposing</param>
      <returns>
        <em>true</em> if disposed as a result of the call; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.EnsureAmbient(FlitBit.Core.Parallel.ContextFlow)">
      <summary>
              Attaches the given context to the current thread.
            </summary>
      <param name="ambient">a new ambient context</param>
      <returns>the provided context</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.ForkAmbient">
      <summary>
              Prepares a copy of the context for use in thread-pool and background threads.
            </summary>
      <returns>an instance suitable for use as a background thread's ambient context</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.ContextFlow.RegisterProvider(FlitBit.Core.Parallel.IContextFlowProvider)">
      <summary>
              Registers a context flow provider.
            </summary>
      <param name="provider">the provider</param>
    </member>
    <member name="E:FlitBit.Core.Parallel.ContextFlow.OnUncaughtException">
      <summary>
              Event fired when uncaught exceptions are raised by parallel operations.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Parallel.ContextFlow.Current">
      <summary>
              Gets the current context flow if one exists.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.DemuxProducer`2">
      <summary>
              Produces a result type R, given an argument type A, demultiplexing concurrent requests.
            </summary>
      <typeparam name="TArgs">argument type A</typeparam>
      <typeparam name="TResult">result type R</typeparam>
    </member>
    <member name="M:FlitBit.Core.Parallel.DemuxProducer`2.ProduceResult(`0,`1@)">
      <summary>
              Produces the requested result.
            </summary>
      <param name="arg" />
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Parallel.DemuxProducer`2.ConsumeAsync(`0)">
      <summary>
            Consumes an product asynchronously, demultiplexing concurrent requests.
            </summary>
      <param name="args">args identifying the product.</param>
    </member>
    <member name="T:FlitBit.Core.Parallel.IContextFlowProvider">
      <summary>
            Interface for classes that provide additional context to an operation's context flow.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.IContextFlowProvider.Capture">
      <summary>
            Callback invoked by the context flow engine to capture context when context needs to flow across threads.
            </summary>
      <returns>an opaque object that the provider can use to correlate the context on another thread</returns>
    </member>
    <member name="M:FlitBit.Core.Parallel.IContextFlowProvider.Attach(FlitBit.Core.Parallel.ContextFlow,System.Object)">
      <summary>
            Callback invoked by the context flow engine to attach a previously captured context to the current thread.
            </summary>
      <param name="context">the local thread's context</param>
      <param name="captureKey">the capture key</param>
    </member>
    <member name="M:FlitBit.Core.Parallel.IContextFlowProvider.Detach(FlitBit.Core.Parallel.ContextFlow,System.Object)">
      <summary>
            Callback invoked by the context flow engine to detach the provider's context from the current thread.
            </summary>
      <param name="context">the local thread's context</param>
      <param name="captureKey">the capture key</param>
    </member>
    <member name="P:FlitBit.Core.Parallel.IContextFlowProvider.ContextKey">
      <summary>
            The provider's unique context key.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Parallel.UncaughtExceptionArgs">
      <summary>
              Event args for uncaught exceptions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Parallel.UncaughtExceptionArgs.#ctor(System.Exception)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="e" />
    </member>
    <member name="P:FlitBit.Core.Parallel.UncaughtExceptionArgs.Error">
      <summary>
              The uncaught exception.
            </summary>
    </member>
    <member name="T:FlitBit.Core.AssemblyLocks">
      <summary>
              Utility class for locks used on assemblies.
            </summary>
    </member>
    <member name="M:FlitBit.Core.AssemblyLocks.GetKeyForAssembly(System.Reflection.Assembly)">
      <summary>
              Gets a key for an assembly suitable for representing the assembly
              as a hashtable or dictionary key without pinning the assembly
              into memory.
            </summary>
      <param name="assembly">the assembly</param>
      <returns>a key for an assembly</returns>
      <requires exception="T:System.ArgumentNullException" csharp="assembly != (System.Reflection.Assembly)null" vb="assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!assembly != (System.Reflection.Assembly)null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.AssemblyLocks.GetLockForAssembly(System.Reflection.Assembly)">
      <summary>
              Gets a lock for an assembly suitable for synchronizing activity
              on the assembly without blocking other activity in the VM.
            </summary>
      <param name="assembly">the assembly</param>
      <returns>an object suitable for locking activity against the assembly</returns>
      <requires exception="T:System.ArgumentNullException" csharp="assembly != (System.Reflection.Assembly)null" vb="assembly &lt;&gt; ((System.Reflection.Assembly)Nothing) ">assembly != (System.Reflection.Assembly)null</requires>
      <exception cref="T:System.ArgumentNullException">!assembly != (System.Reflection.Assembly)null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Buffers.BigEndianBufferReader">
      <summary>
              Helper class that reads big-endian binary data from a buffer.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.BufferReader">
      <summary>
              IBufferReader's base implementation
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferReader">
      <summary>
              Helper for reading binary data from a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)">
      <summary>
              Reads a boolean from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of bytes from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="count">the number of bytes in the array</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)">
      <summary>
              Reads a char from the buffer (two-byte).
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of characters from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="arrayLength">the number of characters in the array</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 * arrayLength &lt;= buffer.Length - offset" vb="2 * arrayLength &lt;= buffer.Length - offset">2 * arrayLength &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 * arrayLength &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)">
      <summary>
              Reads a decimal from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)">
      <summary>
              Reads a double from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)">
      <summary>
              Reads an encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="byteCount">the number of bytes used by the string</param>
      <param name="coder">an encoding used to interpret the bytes</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="byteCount &lt;= buffer.Length - offset" vb="byteCount &lt;= buffer.Length - offset">byteCount &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">byteCount &gt; buffer.Length - offset</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)">
      <summary>
              Reads a Guid from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})">
      <summary>
              Reads an instance of type T from the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="reflector">reflector for reading type T</param>
      <returns>the instance of type T read from the buffer</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a signed byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)">
      <summary>
              Reads a Single from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)">
      <summary>
              Reads a length-prefixed string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)">
      <summary>
              Reads a length-prefixed string from the buffer using the encoding given.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="coder">an encoding used to interpret the bytes read</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="P:FlitBit.Core.Buffers.IBufferReader.Encoding">
      <summary>
              Gets the encoding used when reading string data.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadBoolean(System.Byte[],System.Int32@)">
      <summary>
              Reads a boolean from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBoolean(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a byte array from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a byte array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads a byte array from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="count">number of bytes to read</param>
      <returns>a byte array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadBytes(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadChar(System.Byte[],System.Int32@)">
      <summary>
              Reads a char from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a char value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadChar(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an int16 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an Int32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an Int64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>an Int64 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadDecimal(System.Byte[],System.Int32@)">
      <summary>
              Reads a decimal from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a decimal value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDecimal(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadDouble(System.Byte[],System.Int32@)">
      <summary>
              Reads a double from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a double value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadDouble(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadSingle(System.Byte[],System.Int32@)">
      <summary>
              Reads a single from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a single value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSingle(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadSByte(System.Byte[],System.Int32@)">
      <summary>
              Reads a signed byte from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a signed byte</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadSByte(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt16(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt32 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt32(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads a UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a UInt64 value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadUInt64(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadGuid(System.Byte[],System.Int32@)">
      <summary>
              Reads a Guid from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a guid value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadGuid(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)">
      <summary>
              Reads an length-prefixed string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)">
      <summary>
              Reads an length-prefixed, encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="coder">an encoding to use when decoding the bytes</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadStringWithByteCountPrefix(System.Byte[],System.Int32@,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)">
      <summary>
              Reads an encoded string from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="byteCount">number of bytes to interpret as string data</param>
      <param name="coder">an encoding to use when decoding the bytes</param>
      <returns>a string value</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="byteCount &lt;= buffer.Length - offset" vb="byteCount &lt;= buffer.Length - offset">byteCount &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">byteCount &gt; buffer.Length - offset</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadEncodedString(System.Byte[],System.Int32@,System.Int32,System.Text.Encoding)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Reads an array of characters from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="arrayLength">number of characters to read</param>
      <returns>a char array</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadCharArray(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="2 * arrayLength &lt;= buffer.Length - offset" vb="2 * arrayLength &lt;= buffer.Length - offset">2 * arrayLength &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 * arrayLength &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})">
      <summary>
              Reads an instance of type T from the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <param name="reflector">reflector for reading type T</param>
      <returns>the instance of type T read from the buffer</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.ReadReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0})" inheritedFromTypeName="IBufferReader" exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.Create">
      <summary>
              Creates the default buffer reader.
            </summary>
      <returns>
              a buffer reader matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferReader.Create(System.Text.Encoding)">
      <summary>
              Creates the default buffer reader.
            </summary>
      <param name="enc">the encoding used to interpret strings.</param>
      <returns>
              a buffer reader matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="P:FlitBit.Core.Buffers.BufferReader.Encoding">
      <summary>
              Gets the reader's encoding. This is the encoding used to read string data from the buffer.
            </summary>
      <getter>
        <ensures inheritedFrom="M:FlitBit.Core.Buffers.IBufferReader.get_Encoding" inheritedFromTypeName="IBufferReader" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.LittleEndianBufferReader">
      <summary>
              Implementation of IBufferreader that reads little endian data from a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">an encoding</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt16(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt16 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt32(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt32 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferReader.ReadUInt64(System.Byte[],System.Int32@)">
      <summary>
              Reads an UInt64 from the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where reading begins</param>
      <returns>a value</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.BigEndianBufferWriter">
      <summary>
              Helper class for writing big-endian binary data to a buffer.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.BufferWriter">
      <summary>
              IBufferWriter's base implementation
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferWriter">
      <summary>
              Helper for writing binary data to a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)">
      <summary>
              Fills a buffer.
            </summary>
      <param name="buffer">a buffer</param>
      <param name="offset">offset to begin</param>
      <param name="count">number of bytes to fill</param>
      <param name="value">fill value</param>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)">
      <summary>
              Writes a byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])">
      <summary>
              Writes a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="value.Length &lt;= buffer.Length - offset" vb="value.Length &lt;= buffer.Length - offset">value.Length &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">value.Length &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)">
      <summary>
              Writes from a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="source">the source array</param>
      <param name="sourceOffset">offset into source where copying begins</param>
      <param name="count">number of bytes to copy from source into buffer</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="sourceOffset &gt;= 0" vb="sourceOffset &gt;= 0">sourceOffset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">sourceOffset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= source.Length - sourceOffset" vb="count &lt;= source.Length - sourceOffset">count &lt;= source.Length - sourceOffset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; source.Length - sourceOffset</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)">
      <summary>
              Writes a char value (two-byte) to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)">
      <summary>
              Writes a decimal value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)">
      <summary>
              Writes a Guid value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)">
      <summary>
              Writes an Int16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Writes an Int32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)">
      <summary>
              Writes an Int64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)">
      <summary>
              Writes a signed byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)">
      <summary>
              Writes a float to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="reflector">reflector for writing type T</param>
      <param name="value">the instance</param>
      <returns>number of bytes written</returns>
      <requires exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
      <requires exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="P:FlitBit.Core.Buffers.IBufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
      <getter>
        <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)">
      <summary>
              Fills a buffer.
            </summary>
      <param name="buffer">a buffer</param>
      <param name="offset">offset to begin</param>
      <param name="count">number of bytes to fill</param>
      <param name="value">fill value</param>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.FillBytes(System.Byte[],System.Int32@,System.Int32,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)">
      <summary>
              Writes a boolean value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte)">
      <summary>
              Writes a byte value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])">
      <summary>
              Writes a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the array</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[])" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="value.Length &lt;= buffer.Length - offset" vb="value.Length &lt;= buffer.Length - offset">value.Length &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">value.Length &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)">
      <summary>
              Writes from a byte array to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the source array</param>
      <param name="sourceOffset">offset into source where copying begins</param>
      <param name="count">number of bytes to copy from source into buffer</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="sourceOffset &gt;= 0" vb="sourceOffset &gt;= 0">sourceOffset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">sourceOffset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= source.Length - sourceOffset" vb="count &lt;= source.Length - sourceOffset">count &lt;= source.Length - sourceOffset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; source.Length - sourceOffset</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Byte[],System.Int32,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="count &lt;= buffer.Length - offset" vb="count &lt;= buffer.Length - offset">count &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">count &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char)">
      <summary>
              Writes a char value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int16)">
      <summary>
              Writes an Int16 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int32)">
      <summary>
              Writes an Int32 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Int64)">
      <summary>
              Writes an Int64 to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Int64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)">
      <summary>
              Writes a decimal value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Decimal)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Double)">
      <summary>
              Writes a floating point double value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Double)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Single)">
      <summary>
              Writes a floating point single value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Single)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.SByte)">
      <summary>
              Writes a signed byte to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.SByte)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="1 &lt;= buffer.Length - offset" vb="1 &lt;= buffer.Length - offset">1 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">1 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes a UInt16 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="2 &lt;= buffer.Length - offset" vb="2 &lt;= buffer.Length - offset">2 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">2 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes a UInt32 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="4 &lt;= buffer.Length - offset" vb="4 &lt;= buffer.Length - offset">4 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">4 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes a UInt64 value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="8 &lt;= buffer.Length - offset" vb="8 &lt;= buffer.Length - offset">8 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">8 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Guid)">
      <summary>
              Writes a Guid value to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Guid)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="16 &lt;= buffer.Length - offset" vb="16 &lt;= buffer.Length - offset">16 &lt;= buffer.Length - offset</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">16 &gt; buffer.Length - offset</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)">
      <summary>
              Writes a string to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the string</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.String,System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)">
      <summary>
              Writes an array of chars to the buffer.
            </summary>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="value">the value</param>
      <param name="byteLengthPrefix">whether a byte length prefix should be written</param>
      <param name="coder">an encoding used to transform the string to bytes</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.Write(System.Byte[],System.Int32@,System.Char[],System.Boolean,System.Text.Encoding)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="coder != null" vb="coder &lt;&gt; Nothing">coder != null</requires>
      <exception cref="T:System.ArgumentNullException">coder == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="buffer">the buffer</param>
      <param name="offset">offest into buffer where writing begins</param>
      <param name="reflector">reflector for writing type T</param>
      <param name="value">the instance</param>
      <returns>number of bytes written</returns>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="buffer != null" vb="buffer &lt;&gt; Nothing">buffer != null</requires>
      <exception cref="T:System.ArgumentNullException">buffer == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentNullException" csharp="reflector != null" vb="reflector &lt;&gt; Nothing">reflector != null</requires>
      <exception cref="T:System.ArgumentNullException">reflector == null</exception>
      <requires inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.WriteReflectedObject``1(System.Byte[],System.Int32@,FlitBit.Core.Buffers.IBufferReflector{``0},``0)" inheritedFromTypeName="IBufferWriter" exception="T:System.ArgumentOutOfRangeException" csharp="offset &gt;= 0" vb="offset &gt;= 0">offset &gt;= 0</requires>
      <exception cref="T:System.ArgumentOutOfRangeException">offset &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Create">
      <summary>
              Creates the default buffer writer.
            </summary>
      <returns>
              a buffer writer matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BufferWriter.Create(System.Text.Encoding)">
      <summary>
              Creates the default buffer writer.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
      <returns>
              a buffer writer matching the current machine's
              bit-endianness.
            </returns>
    </member>
    <member name="P:FlitBit.Core.Buffers.BufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
      <getter>
        <ensures inheritedFrom="M:FlitBit.Core.Buffers.IBufferWriter.get_Encoding" inheritedFromTypeName="IBufferWriter" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      </getter>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.BigEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.LittleEndianBufferWriter">
      <summary>
              Helper class for writing little-endian binary data to a buffer.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.#ctor(System.Text.Encoding)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="enc">the encoding used to produce bytes for strings.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt16)">
      <summary>
              Writes an UInt16 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt32)">
      <summary>
              Writes an UInt32 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.LittleEndianBufferWriter.Write(System.Byte[],System.Int32@,System.UInt64)">
      <summary>
              Writes an UInt64 to a buffer.
            </summary>
      <param name="buffer">the target buffer</param>
      <param name="offset">an offset where writing begins</param>
      <param name="value">a value</param>
      <returns>the number of bytes written to the buffer</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc16">
      <summary>
              Utility class for generating CRC16 checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc32">
      <summary>
              Utility class for generating CRC16 checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc32.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc32.ComputeChecksum(System.Byte[],System.Int32,System.Int32)">
      <summary>
              Computes a checksum over an array of bytes beginning with the first and
              continuing to length.
            </summary>
      <param name="bytes" />
      <param name="first" />
      <param name="length" />
      <returns />
    </member>
    <member name="T:FlitBit.Core.Buffers.InitialCrcValue">
      <summary>
              A few common initial CRC values
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.Zeros">
      <summary>
              All zero.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.NonZeroX1D0F">
      <summary>
              Common initial value of 0x1D0F
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.InitialCrcValue.NonZeroXFfff">
      <summary>
              Common initial value of 0xFFFF
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.Crc16Ccitt">
      <summary>
              Utility class for generating CRC16CITT checksums.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16Ccitt.#ctor(FlitBit.Core.Buffers.InitialCrcValue)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="initialValue">which initial value the checksum should use</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.Crc16Ccitt.ComputeChecksum(System.Byte[])">
      <summary>
              Computes a checksum over an array of bytes.
            </summary>
      <param name="bytes">the bytes</param>
      <returns>the checksum</returns>
      <requires exception="T:System.ArgumentNullException" csharp="bytes != null" vb="bytes &lt;&gt; Nothing">bytes != null</requires>
      <exception cref="T:System.ArgumentNullException">bytes == null</exception>
    </member>
    <member name="T:FlitBit.Core.Buffers.BitLayout">
      <summary>
              Enums for bit layouts.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.BitLayout.LittleEndian">
      <summary>
              Little endian - least significant byte first
            </summary>
    </member>
    <member name="F:FlitBit.Core.Buffers.BitLayout.BigEndian">
      <summary>
              Big endian - most significant byte first
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferIO">
      <summary>
              Interface for objects that provide their own buffer IO.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferIO.ReadFromBuffer(FlitBit.Core.Buffers.IBufferReader,System.Byte[],System.Int32@)">
      <summary>
              Reads from the buffer.
            </summary>
      <param name="reader">a buffer reader</param>
      <param name="source">the source buffer</param>
      <param name="offset">
              reference to an offset into the buffer where reading
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <returns>the number of bytes consumed during the read</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferIO.WriteToBuffer(FlitBit.Core.Buffers.IBufferWriter,System.Byte[],System.Int32@)">
      <summary>
              Writes to the buffer.
            </summary>
      <param name="writer">a buffer writer</param>
      <param name="target">the target buffer</param>
      <param name="offset">
              reference to an offset into the buffer where writing
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <returns>total number of bytes written</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferReader">
      <summary>
              CodeContracts Class for IBufferReader
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.IBufferReflector`1">
      <summary>
              Reflects type T onto a buffer.
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReflector`1.ReadFromBuffer(FlitBit.Core.Buffers.IBufferReader,System.Byte[],System.Int32@,`0@)">
      <summary>
              Reads an instance of type T to the buffer.
            </summary>
      <param name="reader">a buffer reader</param>
      <param name="source">the source buffer</param>
      <param name="offset">
              reference to an offset into the buffer where reading
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <param name="target">variable that will hold the instance upon success</param>
      <returns>the number of bytes consumed during the read</returns>
    </member>
    <member name="M:FlitBit.Core.Buffers.IBufferReflector`1.WriteToBuffer(FlitBit.Core.Buffers.IBufferWriter,System.Byte[],System.Int32@,`0)">
      <summary>
              Writes an instance of type T to the buffer.
            </summary>
      <param name="writer">a buffer writer</param>
      <param name="target">the target buffer</param>
      <param name="offset">
              reference to an offset into the buffer where writing
              can begin; upon exit, must be incremented by the number of bytes consumed
            </param>
      <param name="source">the instance of type T being written</param>
      <returns>total number of bytes written</returns>
    </member>
    <member name="T:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferWriter">
      <summary>
              CodeContracts Class for IBufferWriter
            </summary>
    </member>
    <member name="P:FlitBit.Core.Buffers.CodeContracts.ContractForIBufferWriter.Encoding">
      <summary>
              Gets the encoding used when writing string data.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Buffers.Int32SingleUnion">
      <summary>
              Utility struct to convert between Int32 and Single
            </summary>
    </member>
    <member name="M:FlitBit.Core.Buffers.Int32SingleUnion.#ctor(System.Int32)">
      <summary>
              Creates an instance initialized with the given integer.
            </summary>
      <param name="i">An Int32 value.</param>
    </member>
    <member name="M:FlitBit.Core.Buffers.Int32SingleUnion.#ctor(System.Single)">
      <summary>
              Creates an instance initialized with the given floating point number.
            </summary>
      <param name="f">A Single value.</param>
    </member>
    <member name="P:FlitBit.Core.Buffers.Int32SingleUnion.AsInt32">
      <summary>
              Returns the value of the instance as an Int32.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Buffers.Int32SingleUnion.AsSingle">
      <summary>
              Returns the value of the instance as a Single.
            </summary>
    </member>
    <member name="T:FlitBit.Core.CleanupScope">
      <summary>
              Utility class for collecting actions and disposable items for cleanup. Actions and
              disposable items, at dispose time, are either disposed (IDisposables)
              or invoked (Actions) in the reverse order in which they are added to the scope.
            </summary>
    </member>
    <member name="T:FlitBit.Core.ICleanupScope">
      <summary>
              Deliniates a cleanup scope.
            </summary>
    </member>
    <member name="M:FlitBit.Core.ICleanupScope.Add``1(``0)">
      <summary>
              Adds a disposable item to the scope. When the scope
              is disposed all added items are guaranteed to also be
              disposed.
            </summary>
      <typeparam name="T" />
      <param name="item" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
      <ensures csharp="(object)result != null" vb="((Object)result) &lt;&gt; Nothing">(object)result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.ICleanupScope.AddAction(System.Action)">
      <summary>
              Adds an action to be performed upon scope
              completion (on dispose).
            </summary>
      <param name="action" />
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor">
      <summary>
              Creates a new scope.
            </summary>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean)">
      <summary>
              Creates a new scope.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Object,System.Boolean)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="ownerNotifier">the owner, notifier</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Object)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="ownerNotifier">the owner, notifier</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean,System.IDisposable[])">
      <summary>
              Creates a new scope and adds to it the disposable item given.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="items">Items to be disposed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.IDisposable[])">
      <summary>
              Creates a new scope and adds to it the disposable item given.
            </summary>
      <param name="items">Items to be disposed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Boolean,System.Action[])">
      <summary>
              Creates a new scope and adds an action to be performed when the scope is cleaned up.
            </summary>
      <param name="independent">indicates whether the scope is independent of the stack</param>
      <param name="actions">an array of actions to be performed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.#ctor(System.Action[])">
      <summary>
              Creates a new scope and adds an action to be performed when the scope is cleaned up.
            </summary>
      <param name="actions">an array of actions to be performed when the scope is cleaned up.</param>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.ShareScope">
      <summary>
              Shares the scope. Callers must guarantee that there is a matching call to Dispose
              for every call to share. Preferrably by wrapping it in a using clause.
            </summary>
      <returns>the shared scope</returns>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.PerformDispose(System.Boolean)">
      <summary>
              Performs the scope's disposal.
            </summary>
      <param name="disposing">indicates whether the scope is disposing</param>
      <returns>
        <em>true</em> if disposed as a result of the call; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.Add``1(``0)">
      <summary>
              Adds a disposable item to the cleanup scope. Actions and disposable items are collected
              and at cleanup whill be either disposed (IDisposables) or invoked (Actions) in the reverse
              order in which they are added.
            </summary>
      <typeparam name="T">Type of the item being added; ensures IDisposable by inference.</typeparam>
      <param name="item">An item to be disposed when the scope is cleaned up.</param>
      <returns>Returns the item given.</returns>
      <requires inheritedFrom="M:FlitBit.Core.ICleanupScope.Add``1(``0)" inheritedFromTypeName="ICleanupScope" exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
      <ensures inheritedFrom="M:FlitBit.Core.ICleanupScope.Add``1(``0)" inheritedFromTypeName="ICleanupScope" csharp="(object)result != null" vb="((Object)result) &lt;&gt; Nothing">(object)result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.AddAction(System.Action)">
      <summary>
              Adds an action to the cleanup scope. Actions and IDisposables collected in the same queue and
              are either disposed (IDisposables) or invoked (Actions) in the reverse order in which they are
              added.
            </summary>
      <param name="action">An action to be performed when the scope is cleaned up.</param>
      <requires inheritedFrom="M:FlitBit.Core.ICleanupScope.AddAction(System.Action)" inheritedFromTypeName="ICleanupScope" exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.CleanupScope.NewOrSharedScope">
      <summary>
              Shares the ambient scope if it exists; otherwise, creates a new scope.
            </summary>
      <returns>a cleanup scope</returns>
    </member>
    <member name="E:FlitBit.Core.CleanupScope.ItemAdded">
      <summary>
              Event fired when items are added to he scope.
            </summary>
    </member>
    <member name="E:FlitBit.Core.CleanupScope.ItemDisposed">
      <summary>
              Event fired when items are disposed by the scope.
            </summary>
    </member>
    <member name="P:FlitBit.Core.CleanupScope.Current">
      <summary>
              Gets the current "ambient" cleanup scope. This is the nearest
              cleanup scope in the call stack.
            </summary>
    </member>
    <member name="T:FlitBit.Core.CleanupScopeItemEventArgs">
      <summary>
              Provides information about cleanup scope events.
            </summary>
    </member>
    <member name="M:FlitBit.Core.CleanupScopeItemEventArgs.#ctor(System.Object)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="item">the item that caused the event</param>
    </member>
    <member name="P:FlitBit.Core.CleanupScopeItemEventArgs.Item">
      <summary>
              The item that caused the event.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.BitFlags32">
      <summary>
              Utility class for working with bit/flags.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Collections.BitFlags32.Empty">
      <summary>
              Empty instance; all bits turned off.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.#ctor(System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="flags">flag values</param>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Equals(System.Object)">
      <summary>
              Determines if the flags are equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.GetHashCode">
      <summary>
              Gets a hashcode for the instance.
            </summary>
      <returns>a hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.ToString">
      <summary>
              Converts the bit vector into a bit string.
            </summary>
      <returns>bits string</returns>
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.ExcludeFlags(System.Int32)">
      <summary>
              Excludes all of the flags given. (turns off bits corresponding to the bits given)
            </summary>
      <param name="flags">flags to turn off</param>
      <returns>the flags for chaining</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.IncludeFlags(System.Int32)">
      <summary>
              Includes all of the flags given. (turns on bits corresponding to the bits given)
            </summary>
      <param name="flags">flags to turn on</param>
      <returns>the flags for chaining</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Off(System.Int32)">
      <summary>
              Turns the bit off at the position indicated.
            </summary>
      <param name="bit">bit position</param>
      <returns>flags with the indicated bit turned off</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.On(System.Int32)">
      <summary>
              Turns the bit on at the position indicated.
            </summary>
      <param name="bit">bit position</param>
      <returns>flags with the indicated bit turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Equality(FlitBit.Core.Collections.BitFlags32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Equality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Implicit(FlitBit.Core.Collections.BitFlags32)~System.Int32">
      <summary>
              Implicit conversion operator from BitFlags to Int32.
            </summary>
      <param name="flags">value to convert</param>
      <returns>an Int32 representation of the flags</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Implicit(System.Int32)~FlitBit.Core.Collections.BitFlags32">
      <summary>
              Implicit converstion operator from Int32 to BitFlags32
            </summary>
      <param name="flags">value to convert</param>
      <returns>a BitFlags32</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.op_Inequality(FlitBit.Core.Collections.BitFlags32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Inequality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are NOT equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitFlags32.Equals(FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Determines if the flags are equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.Item(System.Int32)">
      <summary>
              Gets and sets bit values to ON (true) or OFF (false).
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.IsEmpty">
      <summary>
              Indicates whether the bit flags are empty (none set to true).
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitFlags32.TrueFlagCount">
      <summary>
              Number of flags currently set to true.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.BitVector">
      <summary>
              Utility structure for working with bit values.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Collections.BitVector.Empty">
      <summary>
              Empty vector; all bits turned off.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.#ctor(System.Int32)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="count">Number of bits contained in the vector</param>
      <requires description="count must be greater than or equal to zero" csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Equals(System.Object)">
      <summary>
              Determines if the vector is equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.GetHashCode">
      <summary>
              Gets the hashcode for the vector.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.ToString">
      <summary>
              Converts the bit vector into a bit string.
            </summary>
      <returns>bits string</returns>
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Copy">
      <summary>
              Makes a copy.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.GetFlags(System.Int32)">
      <summary>
              Gets the BitFlags32 at the index given.
            </summary>
      <param name="index" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.SetFlags(System.Int32,FlitBit.Core.Collections.BitFlags32)">
      <summary>
              Sets the BitFlags32 at the index given.
            </summary>
      <param name="index" />
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.op_Equality(FlitBit.Core.Collections.BitVector,FlitBit.Core.Collections.BitVector)">
      <summary>
              Equality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.op_Inequality(FlitBit.Core.Collections.BitVector,FlitBit.Core.Collections.BitVector)">
      <summary>
              Inequality operator.
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are NOT equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Clone">
      <summary>
              Clones the current instance.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.ICloneable.Clone" inheritedFromTypeName="ICloneable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.BitVector.Equals(FlitBit.Core.Collections.BitVector)">
      <summary>
              Determines if the vector is equal to another.
            </summary>
      <param name="other">the other vector</param>
      <returns>true if equal; otherwise false.</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.Item(System.Int32)">
      <summary>
              Gets and sets the bit at the index given.
            </summary>
      <param name="index">index of the bit to set or get; zero based.</param>
      <returns>whether the bit at the given index is turned on</returns>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.Count">
      <summary>
              Number of flags in the vector.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.IsEmpty">
      <summary>
              Determines if the vector is empty.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.BitVector.TrueFlagCount">
      <summary>
              Number of flags currently set to true.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.EnumerableKeyValuePairs">
      <summary>
              Enumerable interface over key-value-pairs.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.#ctor(System.String,System.Char,System.Char)">
      <summary>
              Creates a new instance from an input string.
            </summary>
      <param name="input">The input string.</param>
      <param name="pairSep">The character that separates key value pairs</param>
      <param name="kvpSep">The character that separates keys from values</param>
      <requires exception="T:System.ArgumentNullException" csharp="input != null" vb="input &lt;&gt; Nothing">input != null</requires>
      <exception cref="T:System.ArgumentNullException">input == null</exception>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.GetEnumerator">
      <summary>
              Gets the enumerator.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="T:FlitBit.Core.Collections.Extensions">
      <summary>
              Contains utility extensions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.ReliableSetValue``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0,``1)">
      <summary>
              Reliably sets the value for a key in the concurrent dictionary.
            </summary>
      <typeparam name="TKey">key type K</typeparam>
      <typeparam name="TValue">value type V</typeparam>
      <param name="dictionary">the dictionary</param>
      <param name="key">the key</param>
      <param name="value">the value</param>
      <returns>
              If there is a value in the dictionary already associated with the key
              then that value is returned; otherwise default(V).
            </returns>
      <remarks>
              Because this method is performed on a concurrent dictionary in a non-blocking
              manner it is possible that parallel operations may change the value associated
              with the key concurrently. What this method guarantees is that the value
              associated with the key is set to the value given; not that it remains so.
              The result indicates the value that was replaced at the time the the operation
              succeeded.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Byte@)">
      <summary>
              Tries to get a named byte value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Boolean@)">
      <summary>
              Tries to get a named boolean value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Byte[]@)">
      <summary>
              Tries to get a named byte array value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Double@)">
      <summary>
              Tries to get a named double value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Decimal@)">
      <summary>
              Tries to get a named decimal value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Single@)">
      <summary>
              Tries to get a named float value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int16@)">
      <summary>
              Tries to get a named short value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int32@)">
      <summary>
              Tries to get a named int value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int64@)">
      <summary>
              Tries to get a named long value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.Int64@,System.Globalization.NumberStyles)">
      <summary>
              Tries to get a named boolean value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <param name="styles">number styles</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.String@)">
      <summary>
              Tries to get a named string value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.SByte@)">
      <summary>
              Tries to get a named signed byte value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt16@)">
      <summary>
              Tries to get a named unsigned short value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt32@)">
      <summary>
              Tries to get a named unsigned int value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.Extensions.TryGetValue(System.Collections.Specialized.NameValueCollection,System.String,System.UInt64@)">
      <summary>
              Tries to get a named unsigned long value.
            </summary>
      <param name="collection">the collection</param>
      <param name="name">the name</param>
      <param name="value">reference to a variable where the value will be returned upon success</param>
      <returns>
        <em>true</em> if the value is present and can be parsed; otherwise <em>false</em></returns>
    </member>
    <member name="T:FlitBit.Core.Collections.KeyValuePair">
      <summary>
              Structure around a key-value-pair.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.#ctor(System.String,System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="k">the key</param>
      <param name="v">the value</param>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.Equals(System.Object)">
      <summary>
              Determines if the pair is equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.GetHashCode">
      <summary>
              Calculates the pair's hashcode.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.ToString">
      <summary>
              Converts the pair to a string representation.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.ValueType.ToString" inheritedFromTypeName="ValueType" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.Equals(FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if the pair is equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.ToString(System.Char)">
      <summary>
              Converts the pair to a string representation using the given separator.
            </summary>
      <param name="sep">a separator character</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.op_Equality(FlitBit.Core.Collections.KeyValuePair,FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if two pairs are equal.
            </summary>
      <param name="lhs">left hand operand</param>
      <param name="rhs">right hand operand</param>
      <returns>
        <em>true</em> if equal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.op_Inequality(FlitBit.Core.Collections.KeyValuePair,FlitBit.Core.Collections.KeyValuePair)">
      <summary>
              Determines if two pairs are unequal.
            </summary>
      <param name="lhs">left hand operand</param>
      <param name="rhs">right hand operand</param>
      <returns>
        <em>true</em> if unequal; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.TryParse(System.String,System.String,FlitBit.Core.Collections.KeyValuePair@)">
      <summary>
              Tries to parse a key-value-pair from an input string.
            </summary>
      <param name="input">the input</param>
      <param name="sep">string separating the key from the value</param>
      <param name="kvp">reference to a variable where the pair will be returned upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Collections.KeyValuePair.TryParse(System.String,System.Char,FlitBit.Core.Collections.KeyValuePair@)">
      <summary>
              Tries to parse a key-value-pair from an input string.
            </summary>
      <param name="input">the input</param>
      <param name="sep">character separating the key from the value</param>
      <param name="kvp">reference to a variable where the pair will be returned upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
    </member>
    <member name="P:FlitBit.Core.Collections.KeyValuePair.Key">
      <summary>
              Gets the pair's key.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Collections.KeyValuePair.Value">
      <summary>
              Gets the pair's value.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Collections.NameValueCollectionExtensions">
      <summary>
              Contains extensions for NameValueCollection
            </summary>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.FirstValueOrDefault``1(System.Collections.Specialized.NameValueCollection,System.String)">
      <summary>
              Transforms the value part of a name-value pair to type T if it
              is present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <returns>a result type T if the name-value pair is present; otherwise default(T)</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.FirstValueOrDefault``1(System.Collections.Specialized.NameValueCollection,System.String,System.Func{System.String,``0})">
      <summary>
              Transforms the value part of a name-value pair to type T if it
              is present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <param name="transform">optional function used to transform the value</param>
      <returns>a result type T if the name-value pair is present; otherwise default(T)</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.ToMultiValue``1(System.Collections.Specialized.NameValueCollection,System.String)">
      <summary>
              Transforms the multi-value part of a name-value pair to an array of type T
              if present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <returns>an enumeration of type T containing values</returns>
      <requires csharp="(() =&gt; {&#xD;&#xA;    {&#xD;&#xA;        System.Func&lt;string, object&gt; local_0 = (System.Func&lt;string, object&gt;)null;&#xD;&#xA;    }&#xD;&#xA;    return nvc != null; })()" vb="(() =&gt; {&#xD;&#xA;    System.Func&lt;string, object&gt; local_0 = ((System.Func(Of String, Object))Nothing);&#xD;&#xA;    return nvc &lt;&gt; Nothing; })()">(() =&gt; {
    {
        System.Func&lt;string, object&gt; local_0 = (System.Func&lt;string, object&gt;)null;
    }
    return nvc != null; })()</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Collections.NameValueCollectionExtensions.ToMultiValue``1(System.Collections.Specialized.NameValueCollection,System.String,System.Func{System.String,``0})">
      <summary>
              Transforms the multi-value part of a name-value pair to an array of type T
              if present in the collection.
            </summary>
      <typeparam name="T">result type T</typeparam>
      <param name="nvc">the collection</param>
      <param name="name">the value's name</param>
      <param name="transform">transforms the string to result type T</param>
      <returns>an enumeration of type T containing values</returns>
      <requires csharp="nvc != null" vb="nvc &lt;&gt; Nothing">nvc != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="T:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2">
      <summary>
              Base class for configuration element collections.
            </summary>
      <typeparam name="TElement">Element type</typeparam>
      <typeparam name="TKey">Key type</typeparam>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.#ctor(System.String,System.String,System.String)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="addElmName">name used to add an element to the collection (default is 'add')</param>
      <param name="clearElmName">name used when clearing elements from the collection (default is 'clear')</param>
      <param name="removeElmName">name used to delete an element from the collection (default is 'remove')</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Add(`0)">
      <summary>
              Adds an element.
            </summary>
      <param name="item" />
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Clear">
      <summary>
              Clears the elements.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.IndexOf(`0)">
      <summary>
              Finds the index of an element.
            </summary>
      <param name="item">the element</param>
      <returns>the index of the element</returns>
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Remove(`0)">
      <summary>
              Removes an element.
            </summary>
      <param name="item">the element</param>
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Remove(`1)">
      <summary>
              Removes an element by key.
            </summary>
      <param name="key">the element's key</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.RemoveAt(System.Int32)">
      <summary>
              Removes an element at the given index.
            </summary>
      <param name="index">the element's index</param>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.PerformGetElementKey(`0)">
      <summary>
              Abstract method; gets the element's key.
            </summary>
      <param name="element">the element</param>
      <returns>the element's key</returns>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.CreateNewElement">
      <summary>
              Creates a new element of type TElement.
            </summary>
      <returns />
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.CreateNewElement" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.GetElementKey(System.Configuration.ConfigurationElement)">
      <summary>
              Gets the element's key.
            </summary>
      <param name="element">the element</param>
      <returns>the element's key</returns>
      <requires inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <ensures inheritedFrom="M:System.Configuration.ConfigurationElementCollection.GetElementKey(System.Configuration.ConfigurationElement)" inheritedFromTypeName="ConfigurationElementCollection" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.GetEnumerator">
      <summary>
              Gets the enumerator.
            </summary>
      <returns>an enumerator</returns>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.Generic.IEnumerable`1.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Item(System.Int32)">
      <summary>
              Accesses an element by index.
            </summary>
      <param name="index">element index</param>
      <returns>
              the element at <paramref name="index" /></returns>
      <setter>
        <requires exception="T:System.ArgumentNullException" csharp="(object)value != null" vb="((Object)value) &lt;&gt; Nothing">(object)value != null</requires>
      </setter>
      <exception cref="T:System.ArgumentNullException">(object)value == null</exception>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Item(`1)">
      <summary>
              Accesses a element by key.
            </summary>
      <param name="key">an element's key</param>
      <returns>the element with the given key</returns>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.CollectionType">
      <summary>
              CollectionType
            </summary>
    </member>
    <member name="P:FlitBit.Core.Configuration.AbstractConfigurationElementCollection`2.Count">
      <summary>
              Number of elements.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Constants">
      <summary>
              Contains global constants.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Constants.NotSoRandomPrime">
      <summary>
              Prime seed for hashcodes; I chose this for its bit distribution. ~P
            </summary>
    </member>
    <member name="T:FlitBit.Core.DataGenerator">
      <summary>
              Utility class for generating random data.
            </summary>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.#ctor(FlitBit.Core.Buffers.IBufferReader)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="reader">A reader for interpreting the random bytes.</param>
      <requires exception="T:System.ArgumentNullException" csharp="reader != null" vb="reader &lt;&gt; Nothing">reader != null</requires>
      <exception cref="T:System.ArgumentNullException">reader == null</exception>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetArray``1(System.Int32)">
      <summary>
              Gets an array of random items.
            </summary>
      <typeparam name="T">item type T</typeparam>
      <param name="length">length of the new array</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetArray``1(System.Int32,System.Boolean)">
      <summary>
              Gets an array of random items.
            </summary>
      <typeparam name="T">item type T</typeparam>
      <param name="length">length of the new array</param>
      <param name="initializeEa">indicates whether each item is initialized with a random value</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetBoolean">
      <summary>
              Gets a random boolean value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetByte">
      <summary>
              Gets a random byte value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetBytes(System.Int32)">
      <summary>
              Gets an array of random byte values.
            </summary>
      <param name="len">Number of bytes in the array.</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetChar">
      <summary>
              Gets a random char value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetCharacterArray(System.Int32)">
      <summary>
              Gets an array of random char values.
            </summary>
      <param name="length">number of characters</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDateTime">
      <summary>
              Gets a random DateTime value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDateTimeOffset">
      <summary>
              Gets a random DateTimeOffset value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDecimal">
      <summary>
              Gets a random decimal value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetDouble">
      <summary>
              Gets a random double floating point value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetEnum``1">
      <summary>
              Gets a random value of enum type E.
            </summary>
      <typeparam name="TEnum">type E</typeparam>
      <returns>the value</returns>
      <requires description="typeof E must be an enum" csharp="typeof(TEnum).IsEnum" vb="typeof(TEnum).IsEnum">typeof(TEnum).IsEnum</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetGuid">
      <summary>
              Gets a random guid value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt16">
      <summary>
              Gets a random Int16 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt32">
      <summary>
              Gets a random Int32 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetInt64">
      <summary>
              Gets a random Int64 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetNumericString(System.Int32)">
      <summary>
              Gets a string of random numeric values.
            </summary>
      <param name="len">number of characters</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetSByte">
      <summary>
              Gets a random signed-byte value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetSingle">
      <summary>
              Gets a random single floating point value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetString(System.Int32)">
      <summary>
              Gets a random string value.
            </summary>
      <param name="length">length of the string</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetStringWithLineBreaks(System.Int32)">
      <summary>
              Gets a random string value.
            </summary>
      <param name="length">length of the string</param>
      <returns>the value</returns>
      <requires csharp="length &gt;= 0" vb="length &gt;= 0">length &gt;= 0</requires>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt16">
      <summary>
              Gets a random UInt16 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt32">
      <summary>
              Gets a random UInt32 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetUInt64">
      <summary>
              Gets a random UInt64 value.
            </summary>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.DataGenerator.GetWords(System.Int32)">
      <summary>
              Gets random fake-words.
            </summary>
      <param name="count">number of words to get.</param>
      <returns>words</returns>
      <requires csharp="count &gt;= 0" vb="count &gt;= 0">count &gt;= 0</requires>
    </member>
    <member name="T:FlitBit.Core.Extensions">
      <summary>
              Various extension methods.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Extensions.CalculateCombinedHashcode``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
      <summary>
              Produces a combined hashcode from the enumerated items.
            </summary>
      <typeparam name="T">element type T</typeparam>
      <param name="items">an enumerable</param>
      <param name="seed">the hash seed (starting value)</param>
      <returns>the combined hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.CountBitsInFlag(System.UInt32)">
      <summary>
              Counts the number of bits turned on.
            </summary>
      <param name="value">a value</param>
      <returns>number of bits turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.CountBitsInFlag(System.Int32)">
      <summary>
              Counts the number of bits turned on.
            </summary>
      <param name="value">a value</param>
      <returns>number of bits turned on</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.DoubleQuote(System.String)">
      <summary>
              Double quotes the given string, delimiting inner quotes.
            </summary>
      <param name="source" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Extensions.EqualsOrItemsEqual``1(``0[],``0[])">
      <summary>
              Determines if the arrays are equal or if the items in two different arrays
              are equal.
            </summary>
      <typeparam name="T">Item type T</typeparam>
      <param name="lhs">Left-hand comparand</param>
      <param name="rhs">Right-hand comparand</param>
      <returns>
        <b>true</b> if the arrays are equal or if the items in the arrays are equal.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.FormatForLogging(System.Exception)">
      <summary>
              Formats an exception for output into the log.
            </summary>
      <param name="ex">the exception</param>
      <returns>a string representation of the exception</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.FormatForLogging(System.Exception,System.Boolean)">
      <summary>
              Formats an exception for output into the log.
            </summary>
      <param name="ex">the exception</param>
      <param name="exposeStackTrace">indicates whether stack trace should be exposed in the output</param>
      <returns>a string representation of the exception</returns>
      <requires exception="T:System.ArgumentNullException" csharp="ex != null" vb="ex &lt;&gt; Nothing">ex != null</requires>
      <exception cref="T:System.ArgumentNullException">ex == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetFullName(System.Delegate)">
      <summary>
              Gets the fully qualified, human readable name for a delegate.
            </summary>
      <param name="d" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="d != null" vb="d &lt;&gt; Nothing">d != null</requires>
      <exception cref="T:System.ArgumentNullException">d == null</exception>
      <requires exception="T:System.ArgumentException" csharp="d.Method != (System.Reflection.MethodInfo)null" vb="d.Method &lt;&gt; ((System.Reflection.MethodInfo)Nothing) ">d.Method != (System.Reflection.MethodInfo)null</requires>
      <exception cref="T:System.ArgumentException">!d.Method != (System.Reflection.MethodInfo)null</exception>
      <requires exception="T:System.ArgumentException" csharp="d.Target != null" vb="d.Target &lt;&gt; Nothing">d.Target != null</requires>
      <exception cref="T:System.ArgumentException">d.Target == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetMemberFromExpression``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
      <summary>
              Gets a member from the expression given.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="expression">the expression</param>
      <returns>the expression's target member</returns>
      <requires exception="T:System.ArgumentNullException" csharp="expression != null" vb="expression &lt;&gt; Nothing">expression != null</requires>
      <exception cref="T:System.ArgumentNullException">expression == null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetReadableFullName(System.Type)">
      <summary>
              Gets a readable full name. Since this method uses reflection it should be used
              rarely. It was created to supply simpler type names when constructing error messages.
            </summary>
      <param name="type">The type.</param>
      <returns>A readable name such as My.Namespace.MyType&lt;string, int&gt;</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.GetReadableSimpleName(System.Type)">
      <summary>
              Gets a readable simple name for a type.
            </summary>
      <param name="type">the type</param>
      <returns>A readable name such as MyType&lt;string, int&gt;</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
    </member>
    <member name="M:FlitBit.Core.Extensions.JsonToDynamic(System.String)">
      <summary>
              Creates a dynamic object over the given JSON.
            </summary>
      <param name="json">JSON input</param>
      <returns>a dynamic object</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.RemoveTrailing(System.String,System.String)">
      <summary>
              Removes a string from the end of another string if present.
            </summary>
      <param name="target">The target string.</param>
      <param name="value">The value to remove.</param>
      <returns>the target string with the value removed</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.ToJson(System.Object)">
      <summary>
              Converts the source object to JSON
            </summary>
      <param name="source">the source</param>
      <returns>the JSON representation of the source</returns>
    </member>
    <member name="M:FlitBit.Core.Extensions.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
              Converts an enumerable to a readonly collection.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="collection">the collection</param>
      <returns>returns a read-only collection</returns>
    </member>
    <member name="T:FlitBit.Core.FactoryProvider">
      <summary>
              Accesses the current factory.
            </summary>
    </member>
    <member name="M:FlitBit.Core.FactoryProvider.SetFactoryProvider(FlitBit.Core.Factory.IFactoryProvider)">
      <summary>
              Sets the factory provider.
            </summary>
      <param name="provider" />
    </member>
    <member name="P:FlitBit.Core.FactoryProvider.Current">
      <summary>
              Gets the current factory provider.
            </summary>
    </member>
    <member name="P:FlitBit.Core.FactoryProvider.Factory">
      <summary>
              Gets and sets the global factory.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.DefaultFactory">
      <summary>
              Factory capable of constructing auto-implemented types.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.IFactory">
      <summary>
              Interface for classes that construct other classes.
            </summary>
      <remarks>
              This interface is used by the frameworks to decouple components from the underlying IoC container.
              While the FlitBit.IoC's IContainer is-a IFactory, it is a trivial matter to build adapters to
              other IoC containers by implementing IFactory to delegate to the IoC of your choice.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CanConstruct``1">
      <summary>
              Indicates whether the factory can construct typeof T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CanConstruct(System.Type)">
      <summary>
              Indicates whether the factory can construct type.
            </summary>
      <param name="type" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CreateInstance``1">
      <summary>
              Creates a new instance of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>a new instance</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.CreateInstance(System.Type)">
      <summary>
              Creates a new instance of the type provided.
            </summary>
      <param name="type">the type of instance to create</param>
      <returns>a new instance</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.GetImplementationType``1">
      <summary>
              Gets the implementation type used when type T is constructed.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns>If the factory can construct instances of type T, the implementation type used; otherwise null.</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.GetImplementationType(System.Type)">
      <summary>
              Gets the implementation type used when type is constructed
            </summary>
      <param name="type">Type</param>
      <returns>If the factory can construct instances of type, the implementation type used; otherwise null.</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactory.RegisterImplementationType``2">
      <summary>
              Notifies the factory that TImpl is an implementation that should be used to fulfill requests for type T.
            </summary>
      <typeparam name="T" />
      <typeparam name="TImpl" />
    </member>
    <member name="P:FlitBit.Core.Factory.IFactory.Next">
      <summary>
              Gets or sets the next factory when factories are chained.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CanConstruct(System.Type)">
      <summary>
              Determins if the factory can construct instances of type.
            </summary>
      <param name="type">The Type</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CreateInstance``1">
      <summary>
              Creates a new instance of type T.
            </summary>
      <typeparam name="T">type T</typeparam>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CreateInstance(System.Type)">
      <summary>
              Creates a new instance of the type provided.
            </summary>
      <returns>a new instance</returns>
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.CanConstruct``1">
      <summary>
              Determins if the factory can construct instances of type T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.GetImplementationType``1">
      <summary>
              Gets the factory's implementation type for type T.
            </summary>
      <typeparam name="T" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.GetImplementationType(System.Type)">
      <summary>
              Gets the factory's implementation type for type
            </summary>
      <param name="type">The type</param>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Factory.DefaultFactory.RegisterImplementationType``2">
      <summary>
              Notifies the factory that TImpl is an implementation that should be used to fulfill requests for type T.
            </summary>
      <typeparam name="T" />
      <typeparam name="TImpl" />
    </member>
    <member name="P:FlitBit.Core.Factory.DefaultFactory.Next">
      <summary>
              Gets or sets the next factory when chained.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Factory.IFactoryProvider">
      <summary>
              Interface for factory providers.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Factory.IFactoryProvider.GetFactory">
      <summary>
              Gets a factory.
            </summary>
      <returns />
    </member>
    <member name="T:FlitBit.Core.CodeContracts.ContractForICleanupScope">
      <summary>
              CodeContracts Class for ICleanupScope
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.LogConfigurationSection">
      <summary>
              Configuration section for log settings.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.CDefaultParallelDispatchThreshold">
      <summary>
              Default parallel disptach threshold
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.CDefaultTraceThreshold">
      <summary>
              Default trace threshold.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.CDefaultStackTraceThreshold">
      <summary>
              Default stack trace threshold
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.PropertyNameDefaultTraceThreshold">
      <summary>
              Property name for defaultSourceLevel.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.PropertyNameDefaultStackTraceThreshold">
      <summary>
              Property name for defaultStackTraceThreshold.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.PropertyNameDefaultWriterType">
      <summary>
              Property name for defaultWriter.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.PropertyNameNamespaces">
      <summary>
              Property name for namespaces
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.PropertyNameParallelDispatchThreshold">
      <summary>
              Property name for parallelDispatchThreshold.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogConfigurationSection.SectionName">
      <summary>
              Configuration section name for trace settings.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.DefaultTraceThreshold">
      <summary>
              The default source levels.
            </summary>
      <seealso cref="T:System.Diagnostics.SourceLevels" />
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.DefaultStackTraceThreshold">
      <summary>
              The default stack trace threshold
            </summary>
      <seealso cref="T:System.Diagnostics.TraceEventType" />
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.DefaultWriterType">
      <summary>
              The default LogEventWriter
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.Namespaces">
      <summary>
              Gets the confgured namespace elements.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.ParallelDispatchThreshold">
      <summary>
              The log sink manager's parallel dispatch threshold.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogConfigurationSection.Current">
      <summary>
              Gets the current configuration section.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.NamespaceElementCollection">
      <summary>
              Configuration element collection for specializing logging for a namespaces.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.NamespaceElementCollection.PerformGetElementKey(FlitBit.Core.Log.NamespaceElement)">
      <summary>
              Gets the element's key
            </summary>
      <param name="element">the element</param>
      <returns>the key</returns>
    </member>
    <member name="T:FlitBit.Core.Log.NamespaceElement">
      <summary>
              Configuration element for specializing logging for a namespace.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.Namespace">
      <summary>
              The namespace to which the configuration element applies.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.TraceThreshold">
      <summary>
              The source levels.
            </summary>
      <seealso cref="T:System.Diagnostics.SourceLevels" />
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.StackTraceThreshold">
      <summary>
              The stack trace threshold
            </summary>
      <seealso cref="T:System.Diagnostics.TraceEventType" />
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.WriterName">
      <summary>
              The name of the sink (in the parent object's 'sinks' collection)
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.WriterTypeName">
      <summary>
              The type of sink to construct.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.TraceThresholdValue">
      <summary>
            The trace threshold as a value.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.NamespaceElement.StackTraceThresholdValue">
      <summary>
            the stack trace threshold as a value.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.Extensions">
      <summary>
              Utility class containing extensions for logging.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.Extensions.GetLogSink(System.Type)">
      <summary>
              Gets the type's log sink.
            </summary>
      <param name="type">the target type.</param>
      <returns>A log sink.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.Extensions.GetLogSink``1(``0)">
      <summary>
              Gets the instance's log sink.
            </summary>
      <param name="item">the target instance.</param>
      <returns>A log sink.</returns>
      <requires exception="T:System.ArgumentNullException" csharp="(object)item != null" vb="((Object)item) &lt;&gt; Nothing">(object)item != null</requires>
      <exception cref="T:System.ArgumentNullException">(object)item == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.Extensions.GetLogSourceName(System.Type)">
      <summary>
              Gets the log source name for a type.
            </summary>
      <param name="type">the type</param>
      <returns>the log source name</returns>
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
    </member>
    <member name="T:FlitBit.Core.Log.ILogSink">
      <summary>
              Interface for log sinks.
            </summary>
      <remarks>
              Log sinks take log events generated by the framework and does something
              useful with them, such as put them in a database or write them to another
              logging service.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Critical(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Error(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Information(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that an informational event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.IsLogging(System.Diagnostics.TraceEventType)">
      <summary>
              Indicates whether the log sink is forwarding messages
              at the source level given.
            </summary>
      <param name="evtType" />
      <returns>true if forwarding; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Resume(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Start(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Stop(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Suspend(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a suspend activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Transfer(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a transfer activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Verbose(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSink.Warning(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSink.TraceThreshold">
      <summary>
              The sink's trace event threshold. Determines what actually gets logged.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSink.Name">
      <summary>
              The log sink's name.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSink.NextSink">
      <summary>
              The next sink in the sink chain; possibly null.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSink.StackTraceThreshold">
      <summary>
              The sink's stacktrace threshold. Determines at which level
              a stacktrace is generated.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.ILogSink.Writer">
      <summary>
              The log event writer associated with the sink.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.ILogSinkGhostWriter">
      <summary>
              Interface for ghost writers. Writing log events are delegated to ghost writers.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSinkGhostWriter.GhostWrite(FlitBit.Core.Log.LogEventWriter,FlitBit.Core.Log.LogEvent)">
      <summary>
              Delegates writing an event.
            </summary>
      <param name="writer" />
      <param name="evt" />
    </member>
    <member name="T:FlitBit.Core.Log.ILogSinkManagement">
      <summary>
              Interface allowing log sink management.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSinkManagement.Reconfigure(System.Diagnostics.TraceEventType,System.Diagnostics.TraceEventType,FlitBit.Core.Log.LogEventWriter,FlitBit.Core.Log.ILogSink)">
      <summary>
              Reconfigures a log sink.
            </summary>
      <param name="evtType" />
      <param name="stackTraceThreshold">a stacktrace threshold</param>
      <param name="writer">an event writer</param>
      <param name="next">the next sink in the chain</param>
    </member>
    <member name="T:FlitBit.Core.Log.ILogSinkManager">
      <summary>
              Manages log sinks.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.ILogSinkManager.GetLogSinkForType(System.Type)">
      <summary>
              Gets the currently configured log sink for the given type.
            </summary>
      <param name="type" />
      <returns />
    </member>
    <member name="P:FlitBit.Core.Log.ILogSinkManager.DefaultLogSink">
      <summary>
              Gets the default log sink.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.LogDataTransform`1">
      <summary>
              Static class used by logging to transform runtime types into textual data.
            </summary>
      <typeparam name="TData">data type TData</typeparam>
    </member>
    <member name="M:FlitBit.Core.Log.LogDataTransform`1.Transform(`0)">
      <summary>
              Transforms data into textual form suitable for the log.
            </summary>
      <param name="data">the data</param>
      <returns>a string representation</returns>
    </member>
    <member name="T:FlitBit.Core.Log.LogEvent">
      <summary>
              Contains information related to log events.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogEvent.#ctor(System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Diagnostics.StackTrace)">
      <summary>
              Creates a new log event.
            </summary>
      <param name="source">the source of the event</param>
      <param name="eventType">the event type</param>
      <param name="appKind">an application specific event kind</param>
      <param name="appKindName">an application specific event name</param>
      <param name="stackTrace">a stack trace associated with the event</param>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogEvent.Equals(System.Object)">
      <summary>
              Determines if the log event is equal to another object.
            </summary>
      <param name="obj">the other object</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Log.LogEvent.GetHashCode">
      <summary>
              Gets the event's hashcode.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Log.LogEvent.ToString">
      <summary>
              Gets the string representation of the log event.
            </summary>
      <returns>string representation</returns>
      <ensures inheritedFrom="M:System.Object.ToString" inheritedFromTypeName="Object" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Log.LogEvent.Equals(FlitBit.Core.Log.LogEvent)">
      <summary>
              Determines if the log event is equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.Message">
      <summary>
              Gets a message associated with the event.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.ComponentName">
      <summary>
              Gets the component name.
            </summary>
      <remarks>
              Component names are established in the configuration
              file and are used to differentiate processes from one-another.
              Component names are a friendly name for a process and work
              well when they identify the process's role such as
              'commercial site', 'corporate site' and 'backend'.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.EnvironmentName">
      <summary>
              Gets the name of the environment where the event originated.
            </summary>
      <remarks>
              Environment names are established in the configuration
              file and are used to differentiate environments where log events
              originate. It only becomes relevant if you collect log events
              from more than one environment and want to differentiate events
              by environment at a later time.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.EventType">
      <summary>
              Gets the event type.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.Kind">
      <summary>
              Gets the event's kind.
            </summary>
      <remarks>
              Event kinds are application specific and should
              be used to identify specific events or event kinds. While
              the EventType is a standardized 'event type' indicator,
              event kinds allow your own identity or severity scheme
              over log events.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.KindName">
      <summary>
              Gets the name of the event's kind.
            </summary>
      <remarks>
              Event kinds are application specific and should
              be used to identify specific events or event kinds. While
              the EventType is a standardized 'event type' indicator,
              event kinds allow your own identity or severity scheme
              over log events.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.MachineName">
      <summary>
              Gets the machine's name (NetBIOS) where the event originated.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.ProcessID">
      <summary>
              Gets the process ID where the event originated.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.ProcessName">
      <summary>
              Gets the process name where the event originated.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.ProcessSequence">
      <summary>
              Sequence suitable for ordering the log events in the order
              in which they were produced within the source process.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.SourceName">
      <summary>
              Gets the name of the log source that originated the event.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.StackTrace">
      <summary>
              Gets the stack trace associated with the log message.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.ThreadID">
      <summary>
              Gets the thread ID where the event originated.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogEvent.TimestampUTC">
      <summary>
              Gets a timestamp indicating when the event originated.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.DataLogEvent`1">
      <summary>
              Log message for data.
            </summary>
      <typeparam name="TData">data type TData</typeparam>
    </member>
    <member name="T:FlitBit.Core.Log.LazyLogEvent">
      <summary>
              Implementation that lazily generates the log message. (when/if it is actually written to a log sink)
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LazyLogEvent.#ctor(System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Func{System.String},System.Diagnostics.StackTrace)">
      <summary>
              Creates a new log event.
            </summary>
      <param name="source">the source of the event</param>
      <param name="eventType">the event type</param>
      <param name="appKind">an application specific event kind</param>
      <param name="appKindName">an application specific event name</param>
      <param name="message">the log message producer</param>
      <param name="stackTrace">a stack trace associated with the event</param>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="P:FlitBit.Core.Log.LazyLogEvent.Message">
      <summary>
              Gets the event's message.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.DataLogEvent`1.#ctor(System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,`0,System.Diagnostics.StackTrace)">
      <summary>
              Creates a new log event.
            </summary>
      <param name="source">the source of the event</param>
      <param name="eventType">the event type</param>
      <param name="appKind">an application specific event kind</param>
      <param name="appKindName">an application specific event name</param>
      <param name="data">data to be transformed for data</param>
      <param name="stackTrace">a stack trace associated with the event</param>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="T:FlitBit.Core.Log.LazyDataLogEvent`1">
      <summary>
              Log message for data.
            </summary>
      <typeparam name="TData">data type TData</typeparam>
    </member>
    <member name="M:FlitBit.Core.Log.LazyDataLogEvent`1.#ctor(System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.Func{`0},System.Diagnostics.StackTrace)">
      <summary>
              Creates a new log event.
            </summary>
      <param name="source">the source of the event</param>
      <param name="eventType">the event type</param>
      <param name="appKind">an application specific event kind</param>
      <param name="appKindName">an application specific event name</param>
      <param name="data">data to be transformed for data</param>
      <param name="stackTrace">a stack trace associated with the event</param>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="T:FlitBit.Core.Log.SimpleLogEvent">
      <summary>
              Simple implementation of log event taking string messages.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.SimpleLogEvent.#ctor(System.String,System.Diagnostics.TraceEventType,System.Int32,System.String,System.String,System.Diagnostics.StackTrace)">
      <summary>
              Creates a new log event.
            </summary>
      <param name="source">the source of the event</param>
      <param name="eventType">the event type</param>
      <param name="appKind">an application specific event kind</param>
      <param name="appKindName">an application specific event name</param>
      <param name="message">the log message</param>
      <param name="stackTrace">a stack trace associated with the event</param>
      <requires exception="T:System.ArgumentNullException" csharp="source != null" vb="source &lt;&gt; Nothing">source != null</requires>
      <exception cref="T:System.ArgumentNullException">source == null</exception>
    </member>
    <member name="P:FlitBit.Core.Log.SimpleLogEvent.Message">
      <summary>
              Gets the event's message.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.LogSink">
      <summary>
              Default implementaton of the LogSink interface.
            </summary>
      <invariant>this._writer != null</invariant>
    </member>
    <member name="F:FlitBit.Core.Log.LogSink.DefaultApplicationSpecificLogEventKind">
      <summary>
              Default value used for ApplicationSpecificLogEventKind when none is given.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Log.LogSink.DefaultApplicationSpecificLogEventName">
      <summary>
              Default value used for ApplicationSpecificLogEventName when none is given.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.#ctor(FlitBit.Core.Log.ILogSinkGhostWriter,System.String,System.Diagnostics.TraceEventType,System.Diagnostics.TraceEventType,FlitBit.Core.Log.LogEventWriter,FlitBit.Core.Log.ILogSink)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="name">the log sink's name</param>
      <param name="evtType">a source level</param>
      <param name="stackTraceThreshold">the stack threshold</param>
      <param name="writer">an event writer</param>
      <param name="next">the next sink in the chain or null</param>
      <param name="ghostWriter" />
      <requires exception="T:System.ArgumentNullException" csharp="ghostWriter != null" vb="ghostWriter &lt;&gt; Nothing">ghostWriter != null</requires>
      <exception cref="T:System.ArgumentNullException">ghostWriter == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <exception cref="T:System.ArgumentNullException">name == null</exception>
      <requires exception="T:System.ArgumentException" csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">name.Length &lt;= 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="writer != null" vb="writer &lt;&gt; Nothing">writer != null</requires>
      <exception cref="T:System.ArgumentNullException">writer == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.IsLogging(System.Diagnostics.TraceEventType)">
      <summary>
              Indicates whether the log sink is forwarding messages
              at the source level given.
            </summary>
      <param name="evtType" />
      <returns>true if forwarding; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Critical(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Error(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Information(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Resume(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Start(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Stop(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a stop activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Suspend(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a suspend activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Transfer(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a transfer activity occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Warning(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="M:FlitBit.Core.Log.LogSink.Verbose(FlitBit.Core.Log.LogEvent)">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="evt">event details</param>
    </member>
    <member name="P:FlitBit.Core.Log.LogSink.TraceThreshold">
      <summary>
              The sink's trace event threshold. Determines what actually gets logged.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSink.Name">
      <summary>
              The sink's name.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSink.NextSink">
      <summary>
              The next sink in the chain.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSink.StackTraceThreshold">
      <summary>
              The sink's stack trace threshold.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSink.Writer">
      <summary>
              The sink's event writer.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.LogSinkExtensions">
      <summary>
              LogSink extensions
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <typeparam name="TData">data type TData</typeparam>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <typeparam name="TData">data type TData</typeparam>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object providing data about the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Critical(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a critical event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Error(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a error event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Information(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a informational event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Resume(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a start activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Start(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Stop(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Suspend(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Transfer(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a resume activity occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a Verbose event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a verbose event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Verbose(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning``1(FlitBit.Core.Log.ILogSink,``0)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,``0)">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning``1(FlitBit.Core.Log.ILogSink,System.Func{``0})">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning``1(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{``0})">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="data">function that resolves an object describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning(FlitBit.Core.Log.ILogSink,System.String,System.Object[])">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.String,System.Object[])">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a formatted message describing the event</param>
      <param name="args">arguments used when formatting the log message</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning(FlitBit.Core.Log.ILogSink,System.Func{System.String})">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkExtensions.Warning(FlitBit.Core.Log.ILogSink,System.Int32,System.String,System.Func{System.String})">
      <summary>
              Notifies the sink that a warning event occurred.
            </summary>
      <param name="sink">the target sink</param>
      <param name="appEventKind">application specific event kind</param>
      <param name="appEventName">application specific event name</param>
      <param name="message">a function that produces a message describing the event</param>
      <returns>the log event</returns>
      <requires exception="T:System.ArgumentNullException" csharp="sink != null" vb="sink &lt;&gt; Nothing">sink != null</requires>
      <exception cref="T:System.ArgumentNullException">sink == null</exception>
    </member>
    <member name="T:FlitBit.Core.Log.LogSinkManager">
      <summary>
            Default log sink manager.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkManager.GhostWrite(FlitBit.Core.Log.LogEventWriter,FlitBit.Core.Log.LogEvent)">
      <summary>
              Delegates writing an event.
            </summary>
      <param name="writer" />
      <param name="evt" />
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkManager.GetLogSinkForType(System.Type)">
      <summary>
              Gets the currently configured log sink for the given type.
            </summary>
      <param name="type" />
      <returns />
    </member>
    <member name="P:FlitBit.Core.Log.LogSinkManager.DefaultLogSink">
      <summary>
              Gets the default log sink.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Log.LogSinkManager.Singleton">
      <summary>
            Gets the single instance.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Log.TraceLogEventWriter">
      <summary>
              Echos log events to a System.Diagnostics trace source.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Log.TraceLogEventWriter.Initialize(System.String)">
      <summary>
              Initializes the trace source.
            </summary>
      <param name="sourceName">the trace source's name</param>
    </member>
    <member name="M:FlitBit.Core.Log.TraceLogEventWriter.WriteLogEvent(FlitBit.Core.Log.LogEvent)">
      <summary>
              Writes the log event to a trace source.
            </summary>
      <param name="evt">the log event</param>
    </member>
    <member name="T:FlitBit.Core.Meta.AutoImplementedAttribute">
      <summary>
              Indicates that an implementation of the interface is generated.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.#ctor(FlitBit.Core.Meta.InstanceScopeKind)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="recommemdedScope">Recommended scope for the resultant type.</param>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.GetImplementation``1(FlitBit.Core.Factory.IFactory,System.Action{System.Type,System.Func{``0}})">
      <summary>
              Gets the implementation for target type T.
            </summary>
      <typeparam name="T">target type T</typeparam>
      <param name="factory">the factory from which the type was requsted.</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if type T is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="M:FlitBit.Core.Meta.AutoImplementedAttribute.GetImplementation(FlitBit.Core.Factory.IFactory,System.Type,System.Action{System.Type,System.Func{System.Object}})">
      <summary>
              Gets the implementation for type
            </summary>
      <param name="factory">the factory from which the type was requested.</param>
      <param name="type">the target types</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if <paramref name="type" /> is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Meta.AutoImplementedAttribute.RecommemdedScope">
      <summary>
              Indicates the recommended instance scope for implementations.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.DefaultImplementationAttribute">
      <summary>
              Indicates the default implementation of an interface.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.#ctor">
      <summary>
              Creates a new instance.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.#ctor(FlitBit.Core.Meta.InstanceScopeKind,System.Type)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="recommemdedScope">Recommended scope for the resultant type.</param>
      <param name="defaultImplType">The default implementation used when non-other is contributed.</param>
    </member>
    <member name="M:FlitBit.Core.Meta.DefaultImplementationAttribute.GetImplementation(FlitBit.Core.Factory.IFactory,System.Type,System.Action{System.Type,System.Func{System.Object}})">
      <summary>
              Gets the implementation for type
            </summary>
      <param name="factory">the factory from which the type was requested.</param>
      <param name="type">the target types</param>
      <param name="complete">callback invoked when the implementation is available</param>
      <returns>
        <em>true</em> if implemented; otherwise <em>false</em>.
            </returns>
      <exception cref="T:System.ArgumentException">thrown if <paramref name="type" /> is not eligible for implementation</exception>
      <remarks>
              If the <paramref name="complete" /> callback is invoked, it must be given either an implementation type
              assignable to type T, or a factory function that creates implementations of type T.
            </remarks>
    </member>
    <member name="P:FlitBit.Core.Meta.DefaultImplementationAttribute.DefaultImplementationType">
      <summary>
              The default implementation used when non-other is contributed.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.InstanceScopeKind">
      <summary>
              Basic enumeration of instance scopes.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.OnDemand">
      <summary>
              Indicates that an instance has a natural scope.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.ContainerScope">
      <summary>
              Indicates that an instance has container scope.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.InstanceScopeKind.Singleton">
      <summary>
              Indicates that an instance is a singleton.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.SensitiveInfoKind">
      <summary>
              Enumeration of sensitivity kinds.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.None">
      <summary>
              Indicates no sensitivity.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.NoLog">
      <summary>
              Indicates the information should not be logged.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Meta.SensitiveInfoKind.PersonallyIdentifying">
      <summary>
              Indicates the information is personally identifiable information.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Meta.SensitiveInfoAttribute">
      <summary>
              Identifies a code element as Personally Identifiable Information
            </summary>
    </member>
    <member name="M:FlitBit.Core.Meta.SensitiveInfoAttribute.#ctor(FlitBit.Core.Meta.SensitiveInfoKind)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="kind">the sensitivity kind</param>
    </member>
    <member name="P:FlitBit.Core.Meta.SensitiveInfoAttribute.Kind">
      <summary>
              Gets the sensitivity kind.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Net.HttpAuthenticationKind">
      <summary>
              Http authentication kinds.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.None">
      <summary>
              None.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Basic">
      <summary>
              Indicates Basic authentication.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Digest">
      <summary>
              Indicates digest authentication.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.HttpAuthenticationKind.Ntlm">
      <summary>
              Indicates NTLM authentication (Windows specific).
            </summary>
    </member>
    <member name="T:FlitBit.Core.Net.ResourceRequestExtensions">
      <summary>
              Extensions for resource oriented HTTP requests.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Net.ResourceRequestExtensions.ResourceClientString">
      <summary>
              String used as the Client in HTTP requests.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.DeserializeResponse``1(System.Net.HttpWebResponse)">
      <summary>
              Deserializes a response to an object of type T.
            </summary>
      <typeparam name="T">typeof T</typeparam>
      <param name="response">the web resposne</param>
      <returns>an instance of type T</returns>
      <requires description="response cannot be null" csharp="response != null" vb="response &lt;&gt; Nothing">response != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.DeserializeResponseAsDynamic(System.Net.HttpWebResponse)">
      <summary>
              Deserializes a response body as a dynamic object.
            </summary>
      <param name="response">the web response</param>
      <returns>a dynamic object over the response body</returns>
      <requires description="response cannot be null" csharp="response != null" vb="response &lt;&gt; Nothing">response != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.GetResponseBodyAsString(System.Net.HttpWebResponse)">
      <summary>
              Gets the response body from a web response.
            </summary>
      <param name="response">the web response</param>
      <returns>the full web response as text</returns>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpGet(System.Net.HttpWebRequest,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <param name="req">the http request</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostJson``1(System.Net.HttpWebRequest,``0,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostJson``1(System.Net.HttpWebRequest,``0,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostXml(System.Net.HttpWebRequest,System.Xml.XmlDocument,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as XML.
            </summary>
      <param name="req">
              the http request
            </param>
      <param name="body">
              the post body
            </param>
      <param name="after">
              an action to be called upon completion
            </param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPostXml(System.Net.HttpWebRequest,System.Xml.XmlDocument,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP POST against a URI as XML.
            </summary>
      <param name="req">
              the http request
            </param>
      <param name="body">
              the post body
            </param>
      <param name="encoding">
              the content encoding
            </param>
      <param name="after">
              an action to be called upon completion
            </param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="body != null" vb="body &lt;&gt; Nothing">body != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutJson``1(System.Net.HttpWebRequest,``0,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutJson``1(System.Net.HttpWebRequest,``0,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as JSON.
            </summary>
      <typeparam name="TBody">body type B</typeparam>
      <param name="req">the http request</param>
      <param name="body">the post body (will be serialized as JSON)</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutText(System.Net.HttpWebRequest,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>Performs an HTTP PUT against a URI as text.</summary>
      <param name="req">The request.</param>
      <param name="body">The body.</param>
      <param name="after">The continuation to be executed after.</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutText(System.Net.HttpWebRequest,System.String,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>Performs an HTTP PUT against a URI as text.</summary>
      <param name="req">The request.</param>
      <param name="body">The body.</param>
      <param name="encoding">The content encoding.</param>
      <param name="after">The continuation to be executed after.</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutXml(System.Net.HttpWebRequest,System.Xml.Linq.XElement,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as XML.
            </summary>
      <param name="req">the http request</param>
      <param name="body">the post body</param>
      <param name="after">an action to be called upon completion</param>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.HttpPutXml(System.Net.HttpWebRequest,System.Xml.Linq.XElement,System.Text.Encoding,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <summary>
              Performs an HTTP PUT against a URI as XML.
            </summary>
      <param name="req">the http request</param>
      <param name="body">the post body</param>
      <param name="encoding">the content encoding</param>
      <param name="after">an action to be called upon completion</param>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <requires csharp="body != null" vb="body &lt;&gt; Nothing">body != null</requires>
      <requires csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.IsSuccess(System.Net.HttpStatusCode)">
      <summary>
              Determines if an HTTP status code indicates succes (within the 200 range).
            </summary>
      <param name="code" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.MakeResourceRequest(System.Uri)">
      <summary>
              Given a URI, makes a web request.
            </summary>
      <param name="uri">the URI</param>
      <returns>a web request</returns>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.MakeResourceRequest(System.Uri,System.Boolean)">
      <summary>
              Given a URI, makes a web request.
            </summary>
      <param name="uri">the URI</param>
      <param name="keepAlive">indicates whether keepalive should be set for the connection</param>
      <returns>a web request</returns>
      <requires exception="T:System.ArgumentNullException" csharp="uri != (System.Uri)null" vb="uri &lt;&gt; ((System.Uri)Nothing) ">uri != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">!uri != (System.Uri)null</exception>
      <requires description="URI must be http(s) scheme" exception="T:System.ArgumentException" csharp="uri.Scheme != default(string) &amp;&amp; uri.Scheme.StartsWith(&quot;http&quot;)" vb="uri.Scheme &lt;&gt; Nothing AndAlso uri.Scheme.StartsWith(&quot;http&quot;)">uri.Scheme != default(string) &amp;&amp; uri.Scheme.StartsWith("http")</requires>
      <exception cref="T:System.ArgumentException">uri.Scheme == default(string) ? !false : !uri.Scheme.StartsWith("http")</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelDelete``1(System.Net.HttpWebRequest,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP DELETE.
            </summary>
      <param name="req">the web request on which to perform the DELETE.</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelGet``1(System.Uri,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Performs an HTTP GET against a URI.
            </summary>
      <param name="uri">the uri</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="uri != (System.Uri)null" vb="uri &lt;&gt; ((System.Uri)Nothing) ">uri != (System.Uri)null</requires>
      <exception cref="T:System.ArgumentNullException">!uri != (System.Uri)null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelGet``1(System.Net.HttpWebRequest,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP GET.
            </summary>
      <param name="req">the web request on which to perform the GET.</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelPost``1(System.Net.HttpWebRequest,System.Byte[],System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP POST.
            </summary>
      <param name="req">the web request on which to perform the POST.</param>
      <param name="postBody">array of bytes containing the post body</param>
      <param name="contentType">indicates the post body's content type</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelPut``1(System.Net.HttpWebRequest,System.Byte[],System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <summary>
              Perfroms an HTTP PUT.
            </summary>
      <param name="req">the web request on which to perform the PUT.</param>
      <param name="postBody">array of bytes containing the post body</param>
      <param name="contentType">indicates the post body's content type</param>
      <param name="responseHandler">a response handler that will read/interpret the response</param>
      <returns>a completion</returns>
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.WithBasicAuth(System.Net.HttpWebRequest,System.String,System.String)">
      <summary>
              Adds HTTP Basic Auth to the request.
            </summary>
      <param name="req">the request</param>
      <param name="username">a username</param>
      <param name="password">a password</param>
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="username != null" vb="username &lt;&gt; Nothing">username != null</requires>
      <exception cref="T:System.ArgumentNullException">username == null</exception>
      <requires exception="T:System.ArgumentException" csharp="username.Length &gt; 0" vb="username.Length &gt; 0">username.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">username.Length &lt;= 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="password != null" vb="password &lt;&gt; Nothing">password != null</requires>
      <exception cref="T:System.ArgumentNullException">password == null</exception>
      <requires exception="T:System.ArgumentException" csharp="password.Length &gt; 0" vb="password.Length &gt; 0">password.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">password.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Process.HealthCheck">
      <summary>
              Base health check object.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Process.HealthCheck.GetStatus">
      <summary>
              Gets the health as a dynamic status object.
            </summary>
      <returns />
    </member>
    <member name="M:FlitBit.Core.Process.HealthCheck.GetStatus(System.Boolean)">
      <summary>
              Gets the health as a dynamic status object.
            </summary>
      <param name="showStackTrace" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Process.HealthCheck.PerformGetStatus(System.Object)">
      <summary>
              Allows specializations to contribute their own status elements.
            </summary>
      <param name="status" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Process.HealthCheck.FromStatusToJson(System.Object)">
      <summary>
              Creates JSON from the provided status object.
            </summary>
      <param name="status" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Process.HealthCheck.IsSuccess(System.Object)">
      <summary>
              Indicates whether the status check was successful.
            </summary>
      <param name="testResult" />
      <returns />
    </member>
    <member name="T:FlitBit.Core.Process.IProcessIdentity">
      <summary>
              Interface for a process identity. Used when a process self-identifies.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.IProcessIdentity.Component">
      <summary>
              Indicates the software component represented by the process.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.IProcessIdentity.Environment">
      <summary>
              Identifies the environment in which the process is operating.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.IProcessIdentity.MachineName">
      <summary>
              Identifies the machine name where the process is located.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.IProcessIdentity.ProcessID">
      <summary>
              Indicates the process' operating system ID.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.IProcessIdentity.ProcessName">
      <summary>
              Indicates the name of the process.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Process.ProcessIdentity">
      <summary>
              Interface for a process identity. Used when a process self-identifies.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentity.Component">
      <summary>
              Indicates the software component represented by the process.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentity.Environment">
      <summary>
              Identifies the environment in which the process is operating.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentity.MachineName">
      <summary>
              Identifies the machine name where the process is located.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentity.ProcessName">
      <summary>
              Indicates process' name.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentity.ProcessID">
      <summary>
              Indicates the process' operating system ID.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Process.ProcessIdentifyConfigurationSection">
      <summary>
              Configuration section for log settings.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.CDefaultEnvironment">
      <summary>
              Default environment string
            </summary>
    </member>
    <member name="F:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.CDefaultTenant">
      <summary>
              Default tenant string
            </summary>
    </member>
    <member name="F:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.PropertyNameComponent">
      <summary>
              Property name for component.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.PropertyNameEnvironment">
      <summary>
              Property name for environment.
            </summary>
    </member>
    <member name="F:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.SectionName">
      <summary>
              Configuration section name for trace settings.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.Component">
      <summary>
              Indicates the name of the component that the current application represents.
              The meaning of "component" is up to the user but in general indicates a
              role that an application performs within a system.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.Environment">
      <summary>
              Indicates the name of the environment in which the application is executing.
              The meaning of "environment" is up to the user but in general indicates an
              environment such as: { dev | test | stage | prod }. In cases where
              events in one environment can be heard by journalers in another environment
              the presence of this value in an event helps with filtering.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Process.ProcessIdentifyConfigurationSection.Current">
      <summary>
              Gets the current configuration section.
            </summary>
    </member>
    <member name="T:FlitBit.Core.PronounceableWordGenerator">
      <summary>
              Generates words that are pronounceable. Original Java code from
              http://www.multicians.org/thvv/gpw.html used for passwords.
              Claimed: This class is free to use without restrictions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.PronounceableWordGenerator.Generate(System.Random,System.Int32,System.Int32,System.Int32)">
      <summary>
              Generates a set of pronounceable fake-words.
            </summary>
      <param name="ran" />
      <param name="wordCount">The number of words to generate.</param>
      <param name="wordLengthMin" />
      <param name="wordLengthMax" />
      <returns>Enumerable words.</returns>
    </member>
    <member name="T:FlitBit.Core.Properties.Resources">
      <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.ResourceManager">
      <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Culture">
      <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Chk_ExpectedOffsetIn32BitRange">
      <summary>
              Looks up a localized string similar to bit must be between 0 and 31 inclusive.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Chk_OffsetWouldResultInBufferOverrun">
      <summary>
              Looks up a localized string similar to offset would result in buffer overrun.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_ExceptionOccurredInParallelThread">
      <summary>
              Looks up a localized string similar to An error occured in a parallel thread..
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_index_out_of_range">
      <summary>
              Looks up a localized string similar to index must be zero or greater but less than count.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_ReactorStopped">
      <summary>
              Looks up a localized string similar to reactor has stopped and cannot perform the operation.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Err_StatusTypeMustBeEnum">
      <summary>
              Looks up a localized string similar to Status&lt;E&gt; requires typeof(E) be an enum.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_AsyncResultAlreadySet">
      <summary>
              Looks up a localized string similar to AsyncResult values are write-once and the value has already been set.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_FutureValueAlreadyPresent">
      <summary>
              Looks up a localized string similar to Future already has a value; futures are write-once..
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_FutureValueNotAvailable">
      <summary>
              Looks up a localized string similar to Future value not yet available.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_TaskStateInvalidExpect">
      <summary>
              Looks up a localized string similar to TaskState is invalid: expected = {0}; actual = {1}.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Error_TaskUnhandledException">
      <summary>
              Looks up a localized string similar to ParallelTask threw an unhandled exception, see the inner exception for details.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.ResourceClientName">
      <summary>
              Looks up a localized string similar to FlitBit Resource Client v.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.TaskBoundaryName">
      <summary>
              Looks up a localized string similar to TaskBoundary #{0}.
            </summary>
    </member>
    <member name="P:FlitBit.Core.Properties.Resources.Warn_ErrorWhileDisposingCleanupScope">
      <summary>
              Looks up a localized string similar to uncaught exception while disposing cleanup scope.
            </summary>
    </member>
    <member name="T:FlitBit.Core.Status`1">
      <summary>
              Utility structure for performing and tracking threadsafe state transitions.
            </summary>
      <typeparam name="TEnum">State type E (should be an enum)</typeparam>
    </member>
    <member name="M:FlitBit.Core.Status`1.#ctor(`0)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="initialState">Initial state</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.Equals(System.Object)">
      <summary>
              Tests whether the status is equal to another
            </summary>
      <param name="obj">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.GetHashCode">
      <summary>
              Gets the hashcode.
            </summary>
      <returns>the hashcode</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ChangeState(`0)">
      <summary>
              Transitions to the given state.
            </summary>
      <param name="value">the target state</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.CompareExchange(`0,`0)">
      <summary>
              Compares the current state to the comparand, if they are equal, replaces the current state with the values
            </summary>
      <param name="value">the value</param>
      <param name="comparand">the comparand</param>
      <returns>the status prior</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.Equals(FlitBit.Core.Status{`0})">
      <summary>
              Tests whethe the status is equal to another.
            </summary>
      <param name="other">the other</param>
      <returns>true if equal; otherwise false</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.HasState(`0)">
      <summary>
              Determines if the current state includes the value given.
            </summary>
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Status`1.IsGreaterThan(`0)">
      <summary>
              Determines if the current state is greater than the comparand.
            </summary>
      <param name="comparand">comparand</param>
      <returns>
        <em>true</em> if the current state is greater than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.IsLessThan(`0)">
      <summary>
              Determines if the current state is less than the comparand.
            </summary>
      <param name="comparand">comparand</param>
      <returns>
        <em>true</em> if the current state is less than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfGreaterThan(`0,`0)">
      <summary>
              Performs a state transition if the current state compares greater than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <returns>
        <em>true</em> if the current state compares greater than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfLessThan(`0,`0)">
      <summary>
              Performs a state transition if the current state compares less than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <returns>
        <em>true</em> if the current state compares less than <paramref name="comparand" />; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SetStateIfLessThan(`0,`0,System.Action)">
      <summary>
              Performs a state transition if the current state compares less than the <paramref name="comparand" /></summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state</param>
      <param name="action">An action to be performed if the state transition succeeds</param>
      <returns>
        <em>true</em> if the current state compares less than <paramref name="comparand" />; otherwise <em>false</em></returns>
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.Status`1.SpinToggleState(`0,`0)">
      <summary>
              Toggles between the toggle state and the desired state - with
              a spin-wait if necessary.
            </summary>
      <param name="desired">desired state</param>
      <param name="toggle">state from which the desired state can toggle</param>
      <returns>
        <em>true</em> if the state transitions to the desired state from the toggle state; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.SpinWaitForState(`0,System.Action)">
      <summary>
              Performs a spinwait until the current state equals the target state.
            </summary>
      <param name="targetState">the target state</param>
      <param name="loopAction">An action to perform inside the spin cycle</param>
    </member>
    <member name="M:FlitBit.Core.Status`1.TrySpinWaitForState(`0,System.Func{`0,System.Boolean})">
      <summary>
              Performs a spinwait until the current state equals the target state.
            </summary>
      <param name="targetState">the target state</param>
      <param name="loopAction">
              An action to perform inside the spin cycle;
              waiting continues until either the target state is reached or the loop
              action returns false.
            </param>
      <returns>
        <em>true</em> if the target state was reached; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0)">
      <summary>
              Tries to transition the state
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state must match current state</param>
      <returns>
        <em>true</em> if the current state matches <paramref name="comparand" /> and the state is transitioned to
              <paramref name="value" />
              ; otherwise <em>false</em></returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0[])">
      <summary>
              Tries to transition the state.
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">one or more comparands</param>
      <returns>
              true if the current state matches one of the comparands and is transitioned to <paramref name="value" />; otherwise
              false
            </returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.TryTransition(`0,`0,System.Action)">
      <summary>
              Tries to transition the state. Upon success executes the action given.
            </summary>
      <param name="value">the target state</param>
      <param name="comparand">comparand state must match current state</param>
      <param name="action">action to perform if the state transition is successful</param>
      <returns>
        <em>true</em> if the current state matches <paramref name="comparand" /> and the state is transitioned to
              <paramref name="value" />
              ; otherwise <em>false</em></returns>
      <requires exception="T:System.ArgumentNullException" csharp="action != null" vb="action &lt;&gt; Nothing">action != null</requires>
      <exception cref="T:System.ArgumentNullException">action == null</exception>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(FlitBit.Core.Status{`0},FlitBit.Core.Status{`0})">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(FlitBit.Core.Status{`0},`0)">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Equality(`0,FlitBit.Core.Status{`0})">
      <summary>
              Specialized == operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(FlitBit.Core.Status{`0},FlitBit.Core.Status{`0})">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(FlitBit.Core.Status{`0},`0)">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.op_Inequality(`0,FlitBit.Core.Status{`0})">
      <summary>
              Specialized != operator
            </summary>
      <param name="lhs">left hand comparand</param>
      <param name="rhs">right hand comparand</param>
      <returns>true if the comparands are not equal</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ToObject(FlitBit.Core.Status{`0})">
      <summary>
              Converts Status&lt;E&gt; to E
            </summary>
      <param name="s">the status</param>
      <returns>the equivalent E</returns>
    </member>
    <member name="M:FlitBit.Core.Status`1.ToStatus(`0)">
      <summary>
              Converts E to Status&lt;E&gt;
            </summary>
      <param name="s">the value</param>
      <returns>the equivalent Status&lt;E&gt;</returns>
    </member>
    <member name="P:FlitBit.Core.Status`1.CurrentState">
      <summary>
              Accesses the current state.
            </summary>
    </member>
    <member name="T:FlitBit.Core.TypeLocks">
      <summary>
              Utility class for locks used on types.
            </summary>
    </member>
    <member name="M:FlitBit.Core.TypeLocks.GetKeyForType(System.Type)">
      <summary>
              Gets a key for a type suitable for representing the type as a hashtable
              or dictionary key without pinning the type and its assembly into memory.
            </summary>
      <param name="type" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.TypeLocks.GetLockForType(System.Type)">
      <summary>
              Gets a lock for a type suitable for synchronizing activity on the type
              without blocking other activity in the VM.
            </summary>
      <param name="type" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="type != (System.Type)null" vb="type &lt;&gt; ((System.Type)Nothing) ">type != (System.Type)null</requires>
      <exception cref="T:System.ArgumentNullException">!type != (System.Type)null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.Util">
      <summary>
              Utility class containing utility functions and extensions.
            </summary>
    </member>
    <member name="M:FlitBit.Core.Util.Dispose``1(``0@)">
      <summary>
              Disposes an instance if it is disposable and sets the reference variable to null.
            </summary>
      <typeparam name="T">typeof item T</typeparam>
      <param name="item">reference to an item to be disposed.</param>
      <returns>
        <em>true</em> if the item is disposed as a result of the call; otherwise <em>false</em>.
            </returns>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1Hash(System.String)">
      <summary>
              Gets an SHA1 hashcode for the value given, using the default UTF8 encoding.
            </summary>
      <param name="value" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1Hash(System.String,System.Text.Encoding)">
      <summary>
              Gets an SHA1 hashcode for the value given.
            </summary>
      <param name="value" />
      <param name="enc" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1HashAndConvertToBase64(System.String)">
      <summary>
              Gets an SHA1 hashcode for the value given and converts it to Base64, using the default UTF8 encoding.
            </summary>
      <param name="value" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.GetSHA1HashAndConvertToBase64(System.String,System.Text.Encoding)">
      <summary>
              Gets an SHA1 hashcode for the value given and converts it to Base64.
            </summary>
      <param name="value" />
      <param name="enc" />
      <returns />
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="enc != null" vb="enc &lt;&gt; Nothing">enc != null</requires>
      <exception cref="T:System.ArgumentNullException">enc == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.InternIt(System.String)">
      <summary>
              Interns a string if it is not already interned.
            </summary>
      <param name="value">the target string</param>
      <returns>the value string interned</returns>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Util.LazyInitializeWithLock``1(``0@,System.Object)">
      <summary>
              Initializes a referenced variable if it is not already initialized.
            </summary>
      <typeparam name="T">variable type T</typeparam>
      <param name="variable">reference to the variable being initialized</param>
      <param name="lck">an object used as a lock if initialization is necessary</param>
      <requires exception="T:System.ArgumentNullException" csharp="lck != null" vb="lck &lt;&gt; Nothing">lck != null</requires>
      <exception cref="T:System.ArgumentNullException">lck == null</exception>
    </member>
    <member name="M:FlitBit.Core.Util.LazyInitializeWithLock``1(``0@,System.Object,System.Func{``0})">
      <summary>
              Initializes a referenced variable if it is not already initialized. Uses
              the <paramref name="factory" /> to create the instance if necessary.
            </summary>
      <typeparam name="T">variable type T</typeparam>
      <param name="variable">reference to the variable being initialized</param>
      <param name="lck">an object used as a lock if initialization is necessary</param>
      <param name="factory">factory delegate</param>
      <returns>the value of the variable, after the lazy initailize</returns>
      <requires exception="T:System.ArgumentNullException" csharp="lck != null" vb="lck &lt;&gt; Nothing">lck != null</requires>
      <exception cref="T:System.ArgumentNullException">lck == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
      <exception cref="T:System.ArgumentNullException">factory == null</exception>
    </member>
    <member name="M:FlitBit.Core.Util.NonBlockingLazyInitializeVolatile``1(``0@,System.Func{``0})">
      <summary>
              Initializes a variable if it doesn't already have a value. This method is
              thread-safe and non-blocking.
            </summary>
      <typeparam name="T">type T</typeparam>
      <param name="value">reference to the value</param>
      <param name="factory">function that creates the instance if it doesn't have a value</param>
      <returns>the instance</returns>
      <requires csharp="factory != null" vb="factory &lt;&gt; Nothing">factory != null</requires>
    </member>
    <member name="M:FlitBit.Core.Util.NonBlockingLazyInitializeVolatile``1(``0@)">
      <summary>
              Initializes a variable if it doesn't already have a value. This method is
              thread-safe and non-blocking.
            </summary>
      <typeparam name="T">type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.Util.VolatileRead``1(``0@)">
      <summary>
              Reads the referenced value within a full-fence.
            </summary>
      <typeparam name="T" />
      <param name="reference" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Util.VolatileWrite``1(``0@,``0)">
      <summary>
              Writes a value to a reference within a full-fence.
            </summary>
      <typeparam name="T" />
      <param name="reference" />
      <param name="value" />
      <returns />
    </member>
    <member name="M:FlitBit.Core.Util.MakeReliableLockFromString(System.String)">
      <summary>
              Interns a string if it is not already interned.
            </summary>
      <param name="value">the target string</param>
      <returns>the value string interned</returns>
      <requires exception="T:System.ArgumentNullException" csharp="value != null" vb="value &lt;&gt; Nothing">value != null</requires>
      <exception cref="T:System.ArgumentNullException">value == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="T:FlitBit.Core.WeakReference`1">
      <summary>
              Strongly typed weak reference.
            </summary>
      <typeparam name="T">referenced type T</typeparam>
    </member>
    <member name="M:FlitBit.Core.WeakReference`1.#ctor(`0)">
      <summary>
              Creates a new instance.
            </summary>
      <param name="target">a reference target.</param>
    </member>
    <member name="M:FlitBit.Core.WeakReference`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
              Creates a new instance (from serialization)
            </summary>
      <param name="info">serialization info</param>
      <param name="context">serialization context</param>
    </member>
    <member name="P:FlitBit.Core.WeakReference`1.StrongTarget">
      <summary>
              Gets the referenced target as type T.
            </summary>
    </member>
    <member name="T:FlitBit.Core.WeakReferenceExtensions">
      <summary>
              Extends the weak reference type.
            </summary>
    </member>
    <member name="M:FlitBit.Core.WeakReferenceExtensions.TryGetStrongTarget``1(System.WeakReference,``0@)">
      <summary>
              Tries to get the target of the reference.
            </summary>
      <typeparam name="T">type T of the referenced object</typeparam>
      <param name="weakRef">the target reference</param>
      <param name="target">reference to a variable that will recieve the target if successful</param>
      <returns>
        <em>true</em> if the reference is alive and has a valid value of type T; otherwise <em>false</em></returns>
      <exception cref="T:System.InvalidCastException">thrown if the target of the reference cannot be cast to type T</exception>
    </member>
    <member name="T:FlitBit.Core.Xml.XDynamic">
      <summary>
              Static class for creating dynamic objects over XML
            </summary>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.Parse(System.String,System.Boolean)">
      <summary>
              Parses the input text and returns a dynamic object.
            </summary>
      <param name="text">source xml text</param>
      <param name="includeRootObject">whether or not the root object is included in the structure of the resulting dynamic</param>
      <returns>a dynamic object shaped like the input xml</returns>
      <requires csharp="text != null" vb="text &lt;&gt; Nothing">text != null</requires>
      <requires csharp="text.Length &gt; 0" vb="text.Length &gt; 0">text.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.Parse(System.String)">
      <summary>
              Parses the input text and returns a dynamic object.
            </summary>
      <param name="text">source xml text</param>
      <returns>a dynamic object shaped like the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.ToDynamic(System.Xml.Linq.XElement)">
      <summary>
              Creates an object over the XElement given.
            </summary>
      <param name="elm">the source element</param>
      <returns>an object shaped like the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.AddAttributesToDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Xml.Linq.XElement)">
      <summary>
              Adds attributes from an element into the dictionary given.
            </summary>
      <param name="expando">target dictionary</param>
      <param name="elm">source element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XDynamic.AddElementsToDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Xml.Linq.XElement)">
      <summary>
              Adds child elements from an element into the dictionary given.
            </summary>
      <param name="expando">target dictionary</param>
      <param name="elm">source element</param>
    </member>
    <member name="T:FlitBit.Core.Xml.XElementExtensions">
      <summary>
              Extensions for working with XElement and XML
            </summary>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadBooleanOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadByteOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named byte value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadBytesOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named byte array value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadCharOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named char value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadDecimalOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named decimal value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadDoubleOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named double value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadGuidOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Guid value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt16OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int16 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt32OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int32 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadInt64OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named Int64 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@,System.Boolean)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Boolean@,System.Func{System.Boolean})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@,System.Byte)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Byte@,System.Func{System.Byte})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@,System.Char)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Char@,System.Func{System.Char})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@,System.DateTime)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.DateTime@,System.Func{System.DateTime})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@,System.Decimal)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Decimal@,System.Func{System.Decimal})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@,System.Double)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Double@,System.Func{System.Double})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@,System.Int16)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int16@,System.Func{System.Int16})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@,System.Int32)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int32@,System.Func{System.Int32})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@,System.Int64)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Int64@,System.Func{System.Int64})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@,``0)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault``1(System.Xml.Linq.XElement,System.String,``0@,System.Func{``0})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@,System.SByte)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.SByte@,System.Func{System.SByte})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@,System.Single)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.Single@,System.Func{System.Single})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@,System.String)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.String@,System.Func{System.String})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@,System.UInt16)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt16@,System.Func{System.UInt16})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@,System.UInt32)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt32@,System.Func{System.UInt32})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@,System.UInt64)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefault(System.Xml.Linq.XElement,System.String,System.UInt64@,System.Func{System.UInt64})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@,``0)">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadNamedValueOrDefaultAsEnum``1(System.Xml.Linq.XElement,System.String,``0@,System.Func{``0})">
      <summary>
              Read a named value from an xml element; if the value doesn't exist, value is set to
              the default given.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success.</param>
      <param name="defa">default value used if no value is present on the element</param>
      <requires csharp="defa != null" vb="defa &lt;&gt; Nothing">defa != null</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadSByteOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named SByte value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadSingleOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named single value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadStringOrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named String value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt16OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt16 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt32OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt32 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ReadUInt64OrDefault(System.Xml.Linq.XElement,System.String)">
      <summary>
              Reads a named UInt64 value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <returns>the value</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.ToDynamic(System.Xml.Linq.XElement)">
      <summary>
              Converts an XElement into a dynamic XML object.
            </summary>
      <param name="xml">the source xml element</param>
      <returns>a dynamic object shaped according to the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Boolean@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Byte@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Char@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.DateTime@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Decimal@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Double@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int16@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int32@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Int64@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue``1(System.Xml.Linq.XContainer,System.String,``0@)">
      <summary>
              Tries to read a named value from an xml container.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.SByte@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.Single@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.String@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt16@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt32@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValue(System.Xml.Linq.XElement,System.String,System.UInt64@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.TryReadNamedValueAsEnum``1(System.Xml.Linq.XElement,System.String,``0@)">
      <summary>
              Tries to read a named value from an xml element.
            </summary>
      <param name="element">element</param>
      <param name="name">name</param>
      <param name="value">reference to a variable that will receive the value upon success</param>
      <returns>
        <em>true</em> if successful; otherwise <em>false</em></returns>
      <requires csharp="element != null" vb="element &lt;&gt; Nothing">element != null</requires>
      <requires csharp="name != null" vb="name &lt;&gt; Nothing">name != null</requires>
      <requires csharp="name.Length &gt; 0" vb="name.Length &gt; 0">name.Length &gt; 0</requires>
      <requires description="typeof(T) must be an enum" csharp="typeof(T).IsEnum" vb="typeof(T).IsEnum">typeof(T).IsEnum</requires>
    </member>
    <member name="M:FlitBit.Core.Xml.XElementExtensions.XmlToDynamic(System.String)">
      <summary>
              Converts a string into a dynamic XML object.
            </summary>
      <param name="text">the source xml</param>
      <returns>a dynamic object shaped according to the input xml</returns>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkManager.GetFallbackLogSink(System.String,System.String)">
      <requires exception="T:System.ArgumentNullException" csharp="key != null" vb="key &lt;&gt; Nothing">key != null</requires>
      <exception cref="T:System.ArgumentNullException">key == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="namesp != null" vb="namesp &lt;&gt; Nothing">namesp != null</requires>
      <exception cref="T:System.ArgumentNullException">namesp == null</exception>
      <requires exception="T:System.ArgumentException" csharp="namesp.Length &gt;= 0" vb="namesp.Length &gt;= 0">namesp.Length &gt;= 0</requires>
      <exception cref="T:System.ArgumentException">namesp.Length &lt; 0</exception>
    </member>
    <member name="M:FlitBit.Core.Log.LogSinkManager.SliceNamespace(System.String@)">
      <requires exception="T:System.ArgumentNullException" csharp="namesp != null" vb="namesp &lt;&gt; Nothing">namesp != null</requires>
      <exception cref="T:System.ArgumentNullException">namesp == null</exception>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ExecuteHttpVerb(System.Net.HttpWebRequest,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
      <exception cref="T:System.ArgumentNullException">after == null</exception>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ExecuteHttpVerbWithPostBody(System.Net.HttpWebRequest,System.Byte[],System.String,System.String,System.Action{System.Exception,System.Net.HttpWebResponse})">
      <requires exception="T:System.ArgumentNullException" csharp="req != null" vb="req &lt;&gt; Nothing">req != null</requires>
      <exception cref="T:System.ArgumentNullException">req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <requires exception="T:System.ArgumentNullException" csharp="after != null" vb="after &lt;&gt; Nothing">after != null</requires>
      <exception cref="T:System.ArgumentNullException">after == null</exception>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelExecuteHttpVerb``1(System.Net.HttpWebRequest,System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <requires exception="T:System.ArgumentNullException" csharp="new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass5&lt;T&gt;(){&#xD;&#xA;    req = req, &#xD;&#xA;    responseHandler = responseHandler, &#xD;&#xA;}.req != null" vb="(() =&gt; {&#xD;&#xA;    FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass5&lt;T&gt; local_0_prime = New FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass5(Of T)();&#xD;&#xA;    (local_0_prime.req = req)&#xD;&#xA;    (local_0_prime.responseHandler = responseHandler)&#xD;&#xA;    return local_0_prime; })().req &lt;&gt; Nothing">new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass5&lt;T&gt;(){
    req = req, 
    responseHandler = responseHandler, 
}.req != null</requires>
      <exception cref="T:System.ArgumentNullException">new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass5&lt;T&gt;(){
    req = req, 
    responseHandler = responseHandler, 
}.req == null</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Net.ResourceRequestExtensions.ParallelExecuteHttpVerbWithPostBody``1(System.Net.HttpWebRequest,System.Byte[],System.String,System.String,System.Func{System.Net.HttpWebResponse,``0})">
      <requires exception="T:System.ArgumentNullException" csharp="new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;(){&#xD;&#xA;    req = req, &#xD;&#xA;    responseHandler = responseHandler, &#xD;&#xA;}.req != null" vb="(() =&gt; {&#xD;&#xA;    FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt; local_0_prime = New FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass8(Of T)();&#xD;&#xA;    (local_0_prime.req = req)&#xD;&#xA;    (local_0_prime.responseHandler = responseHandler)&#xD;&#xA;    return local_0_prime; })().req &lt;&gt; Nothing">new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;(){
    req = req, 
    responseHandler = responseHandler, 
}.req != null</requires>
      <exception cref="T:System.ArgumentNullException">new FlitBit.Core.Net.ResourceRequestExtensions.&lt;&gt;c__DisplayClass8&lt;T&gt;(){
    req = req, 
    responseHandler = responseHandler, 
}.req == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="postBody != null" vb="postBody &lt;&gt; Nothing">postBody != null</requires>
      <exception cref="T:System.ArgumentNullException">postBody == null</exception>
      <requires exception="T:System.ArgumentNullException" csharp="contentType != null" vb="contentType &lt;&gt; Nothing">contentType != null</requires>
      <exception cref="T:System.ArgumentNullException">contentType == null</exception>
      <requires exception="T:System.ArgumentException" csharp="contentType.Length &gt; 0" vb="contentType.Length &gt; 0">contentType.Length &gt; 0</requires>
      <exception cref="T:System.ArgumentException">contentType.Length &lt;= 0</exception>
      <ensures csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
    </member>
    <member name="M:FlitBit.Core.Collections.EnumerableKeyValuePairs.System#Collections#IEnumerable#GetEnumerator">
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result != null" vb="result &lt;&gt; Nothing">result != null</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_Model == this.get_Model" vb="result.get_Model = Me.get_Model">result.get_Model == this.get_Model</ensures>
      <ensures inheritedFrom="M:System.Collections.IEnumerable.GetEnumerator" inheritedFromTypeName="IEnumerable" csharp="result.get_CurrentIndex == -1" vb="result.get_CurrentIndex = -1">result.get_CurrentIndex == -1</ensures>
    </member>
  </members>
</doc>